--[[
	KRT.lua
	- Main addon file for Kader Raid Tools (KRT).
	- Handles core logic, event registration, and module initialization.
]]

local addonName, addon                  = ...
local L                                 = addon.L
local Utils                             = addon.Utils

local _G                                = _G
_G["KRT"]                               = addon

---============================================================================
-- Saved Variables
-- These variables are persisted across sessions for the addon.
---============================================================================

KRT_Debug                               = KRT_Debug or {}
KRT_Options                             = KRT_Options or {}
KRT_Raids                               = KRT_Raids or {}
KRT_Players                             = KRT_Players or {}
KRT_Warnings                            = KRT_Warnings or {}
KRT_ExportString                        = KRT_ExportString or "$I,$N,$S,$W,$T,$R,$H:$M,$d/$m/$y"
KRT_Spammer                             = KRT_Spammer or {}
KRT_CurrentRaid                         = KRT_CurrentRaid or nil
KRT_LastBoss                            = KRT_LastBoss or nil
KRT_NextReset                           = KRT_NextReset or 0
KRT_SavedReserves                       = KRT_SavedReserves or {}
KRT_PlayerCounts                        = KRT_PlayerCounts or {}

---============================================================================
-- Core Addon Frames & Locals
---============================================================================

-- Addon UI Frames
local mainFrame                         = CreateFrame("Frame")
local UIMaster, UIConfig, UISpammer, UIChanges, UIWarnings, UILogger

-- Local Variables
local unitName                          = UnitName("player")

-- Rolls & Loot
local trader, winner
local holder, banker, disenchanter
local isLootOpen                        = false
local currentRollType                   = 4 -- Default to Free Roll
local currentRollItem                   = 0
local isFromInventory                   = false
local lootCount                         = 0
local rollsCount                        = 0
local itemCount                         = 1
local itemTraded                        = 0

-- Function placeholders for loot helpers
local ItemExists, ItemIsSoulbound, GetItem
local GetItemIndex, GetItemName, GetItemLink, GetItemTexture

---============================================================================
-- Constants & Static Data
---============================================================================

-- Roll Types Enum
local ROLL_TYPES                        = {
	MAINSHEC   = 1,
	OFFSPEC    = 2,
	RESERVED   = 3,
	FREE       = 4,
	BANK       = 5,
	DISENCHANT = 6,
	HOLD       = 7,
	DKP        = 8
}

-- Roll Type Display Text
local LOOT_TYPES_TEXT                   = {
	L.BtnMS,
	L.BtnOS,
	L.BtnSR,
	L.BtnFree,
	L.BtnBank,
	L.BtnDisenchant,
	L.BtnHold
}

-- Roll Type Colored Display Text
local LOOT_TYPES_COLORED                = {
	GREEN_FONT_COLOR_CODE .. L.BtnMS .. FONT_COLOR_CODE_CLOSE,
	LIGHTYELLOW_FONT_COLOR_CODE .. L.BtnOS .. FONT_COLOR_CODE_CLOSE,
	"|cffa335ee" .. L.BtnSR .. FONT_COLOR_CODE_CLOSE,
	NORMAL_FONT_COLOR_CODE .. L.BtnFree .. FONT_COLOR_CODE_CLOSE,
	ORANGE_FONT_COLOR_CODE .. L.BtnBank .. FONT_COLOR_CODE_CLOSE,
	RED_FONT_COLOR_CODE .. L.BtnDisenchant .. FONT_COLOR_CODE_CLOSE,
	HIGHLIGHT_FONT_COLOR_CODE .. L.BtnHold .. FONT_COLOR_CODE_CLOSE,
	GREEN_FONT_COLOR_CODE .. "DKP" .. FONT_COLOR_CODE_CLOSE,
}

-- Item Quality Colors
local ITEM_QUALITY_COLORS               = {
	[1] = "ff9d9d9d", -- Poor
	[2] = "ffffffff", -- Common
	[3] = "ff1eff00", -- Uncommon
	[4] = "ff0070dd", -- Rare
	[5] = "ffa335ee", -- Epic
	[6] = "ffff8000", -- Legendary
	[7] = "ffe6cc80", -- Artifact / Heirloom
}

-- Class Colors
local CLASS_COLORS                      = {
	["UNKNOWN"]     = "ffffffff",
	["DEATHKNIGHT"] = "ffc41f3b",
	["DRUID"]       = "ffff7d0a",
	["HUNTER"]      = "ffabd473",
	["MAGE"]        = "ff40c7eb",
	["PALADIN"]     = "fff58cba",
	["PRIEST"]      = "ffffffff",
	["ROGUE"]       = "fffff569",
	["SHAMAN"]      = "ff0070de",
	["WARLOCK"]     = "ff8787ed",
	["WARRIOR"]     = "ffc79c6e",
}

-- Raid Target Markers
local RAID_TARGET_MARKERS               = {
	"{circle}",
	"{diamond}",
	"{triangle}",
	"{moon}",
	"{square}",
	"{cross}",
	"{skull}"
}

-- Shared Frame Title String
local TITLE_STRING                      = "|cfff58cbaK|r|caaf49141RT|r : %s"

---============================================================================
-- Cached Functions & Libraries
---============================================================================

-- Local function placeholders
local TriggerEvent
local LoadOptions

-- Cached WoW API & Lua Functions
local SendChatMessage                   = _G.SendChatMessage
local tinsert, tremove, tconcat, twipe  = table.insert, table.remove, table.concat, table.wipe
local pairs, ipairs, type, select, next = pairs, ipairs, type, select, next
local format, match, find, strlen       = string.format, string.match, string.find, string.len
local strsub, gsub, lower, upper        = string.sub, string.gsub, string.lower, string.upper
local tostring, tonumber, ucfirst       = tostring, tonumber, _G.string.ucfirst

-- External Libraries
local deformat                          = LibStub("LibDeformat-3.0")
local BossIDs                           = LibStub("LibBossIDs-1.0")

---============================================================================
-- Core Functions
---============================================================================

--
-- Returns the name of the main addon frame.
--
function addon:GetFrameName()
	if UIMaster then
		return UIMaster:GetName()
	end
end

--
-- Sends a message to the addon's debugger module.
-- @param level The debug level (e.g., "INFO", "ERROR").
-- @param msg The message string, supports format placeholders.
-- @param ... Values for the format placeholders.
--
function addon:Debug(level, msg, ...)
	if self.Debugger then
		self.Debugger:Add(level, msg, ...)
	end
end

---============================================================================
-- Debugger Module
-- Handles the creation and management of the debug window.
---============================================================================
do
	addon.Debugger = {}
	local Debugger = addon.Debugger

	-- Local variables
	local debugFrame, debugScrollFrame
	local isDebuggerOpen = false
	local messageBuffer = {}

	local LOG_LEVEL_PRIORITY = { DEBUG = 1, INFO = 2, WARN = 3, ERROR = 4 }
	local LOG_LEVEL_NAMES = { [1] = "DEBUG", [2] = "INFO", [3] = "WARN", [4] = "ERROR" }
	local minLogLevel = "DEBUG"
	local MAX_DEBUG_LOGS = 500

	--
	-- Called when the debugger frame is loaded.
	--
	function Debugger:OnLoad(self)
		debugFrame = self
		local frameName = debugFrame:GetName()
		debugScrollFrame = _G[frameName .. "ScrollFrame"]
		debugFrame:SetMovable(true)
		debugFrame:EnableMouse(true)
		debugFrame:RegisterForDrag("LeftButton")
		debugFrame:SetScript("OnDragStart", debugFrame.StartMoving)
		debugFrame:SetScript("OnDragStop", debugFrame.StopMovingOrSizing)

		-- Restore saved position if available
		if KRT_Debug and KRT_Debug.Pos and KRT_Debug.Pos.point then
			local p = KRT_Debug.Pos
			debugFrame:ClearAllPoints()
			debugFrame:SetPoint(p.point, p.relativeTo or UIParent, p.relativePoint, p.xOfs, p.yOfs)
		end
	end

	--
	-- Shows the debugger window.
	--
	function Debugger:Show()
		if not debugFrame then return end
		debugFrame:Show()

		if not isDebuggerOpen then
			isDebuggerOpen = true
			self:Add("DEBUG", "Debugger window opened.")
			self:AddBufferedMessages()
		end
	end

	--
	-- Hides the debugger window.
	--
	function Debugger:Hide()
		if debugFrame then
			debugFrame:Hide()
			isDebuggerOpen = false
		end
	end

	--
	-- Clears all messages from the debug output.
	--
	function Debugger:Clear()
		if debugScrollFrame then
			debugScrollFrame:Clear()
		end
		twipe(messageBuffer)
	end

	--
	-- Sets the minimum log level to display.
	--
	function Debugger:SetMinLevel(level)
		if type(level) == "number" and LOG_LEVEL_NAMES[level] then
			minLogLevel = LOG_LEVEL_NAMES[level]
			self:Add("INFO", "Log level set to [%s]", minLogLevel)
		elseif type(level) == "string" then
			level = upper(level)
			if LOG_LEVEL_PRIORITY[level] then
				minLogLevel = level
				self:Add("INFO", "Log level set to [%s]", minLogLevel)
			else
				self:Add("ERROR", "Invalid log level: %s", level)
			end
		else
			self:Add("ERROR", "Invalid log level type.")
		end
	end

	--
	-- Returns the current minimum log level.
	--
	function Debugger:GetMinLevel()
		return minLogLevel
	end

	--
	-- Adds a message to the debug log.
	--
	function Debugger:Add(level, msg, ...)
		-- Allow calling with Add("message") which defaults to DEBUG level.
		if not msg then
			msg = level
			level = "DEBUG"
		end

		if LOG_LEVEL_PRIORITY[level] < LOG_LEVEL_PRIORITY[minLogLevel] then return end

		if select('#', ...) > 0 then
			local safeArgs = {}
			for i = 1, select('#', ...) do
				local v = select(i, ...)
				tinsert(safeArgs, type(v) == "string" and v or tostring(v))
			end
			msg = format(msg, unpack(safeArgs))
		end
		local line = format("[%s][%s] %s", date("%H:%M:%S"), level, msg)

		-- If the frame isn't ready, buffer the message.
		if not debugScrollFrame then
			tinsert(messageBuffer, line)
			while #messageBuffer > MAX_DEBUG_LOGS do
				tremove(messageBuffer, 1)
			end
			return
		end

		-- Set color based on level
		local r, g, b = 1, 1, 1 -- Default white
		if level == "ERROR" then
			r, g, b = 1, 0.2, 0.2
		elseif level == "WARN" then
			r, g, b = 1, 0.8, 0
		elseif level == "INFO" then
			r, g, b = 0.6, 0.8, 1
		elseif level == "DEBUG" then
			r, g, b = 0.8, 0.8, 0.8
		end

		debugScrollFrame:AddMessage(line, r, g, b)

		-- Truncate persistent log table if it exists
		if KRT_Debug and KRT_Debug.Debugs then
			tinsert(KRT_Debug.Debugs, line)
			while #KRT_Debug.Debugs > MAX_DEBUG_LOGS do
				tremove(KRT_Debug.Debugs, 1)
			end
		end
	end

	--
	-- Adds any buffered messages to the scroll frame once it's available.
	--
	function Debugger:AddBufferedMessages()
		for _, msg in ipairs(messageBuffer) do
			debugScrollFrame:AddMessage(msg)
		end
		twipe(messageBuffer)
	end

	--
	-- Returns true if the debugger window is visible.
	--
	function Debugger:IsShown()
		return debugFrame and debugFrame:IsShown()
	end
end

---============================================================================
-- Callback System
-- A simple system for registering and triggering custom events.
---============================================================================
do
	local callbacks = {}

	--
	-- Registers a new callback function for an event.
	--
	function addon:RegisterCallback(event, func)
		if not event or type(func) ~= "function" then
			error(L.StrCbErrUsage)
		end
		callbacks[event] = callbacks[event] or {}
		tinsert(callbacks[event], func)
		return #callbacks
	end

	--
	-- Triggers a registered event, calling all associated functions.
	--
	function TriggerEvent(event, ...)
		if not callbacks[event] then return end
		for _, func in ipairs(callbacks[event]) do
			local ok, err = pcall(func, event, ...)
			if not ok then
				addon:PrintError(L.StrCbErrExec:format(tostring(func), tostring(event), err))
			end
		end
	end
end

---============================================================================
-- Event System
-- Manages WoW API event registration for the addon.
---============================================================================
do
	local events = {}

	--
	-- Handles all registered WoW API events.
	--
	local function HandleEvent(self, event, ...)
		if event == "ADDON_LOADED" then
			LoadOptions()
		end
		if not events[event] then return end
		for _, object in ipairs(events[event]) do
			if type(object[event]) == "function" then
				object[event](object, ...)
			end
		end
	end

	--
	-- Registers one or more WoW API events for a given object (usually a module).
	--
	function addon:RegisterEvents(...)
		for i = 1, select("#", ...) do
			local event = select(i, ...)
			events[event] = events[event] or {}
			tinsert(events[event], self)
			mainFrame:RegisterEvent(event)
		end
	end

	--
	-- Unregisters all events for a given object.
	--
	function addon:UnregisterEvents()
		for event, objects in pairs(events) do
			for i = #objects, 1, -1 do
				if objects[i] == self then
					tremove(objects, i)
				end
			end
			if #objects == 0 then
				events[event] = nil
				mainFrame:UnregisterEvent(event)
			end
		end
	end

	-- Register initial events and scripts
	addon:RegisterEvents("ADDON_LOADED")
	mainFrame:SetScript("OnEvent", HandleEvent)
	mainFrame:SetScript("OnUpdate", Utils.run)
end

---============================================================================
-- Raid Helpers Module
-- Manages raid state, roster, boss kills, and loot logging.
---============================================================================
do
	addon.Raid = {}
	local Raid = addon.Raid
	local inRaid = false
	local numRaidMembers = 0

	-- Cached WoW API
	local GetLootMethod = _G.GetLootMethod
	local GetNumPartyMembers = _G.GetNumPartyMembers
	local GetNumRaidMembers = _G.GetNumRaidMembers
	local GetRaidRosterInfo = _G.GetRaidRosterInfo

	--------------------------------------------------------------------------
	-- Logger Functions
	--------------------------------------------------------------------------

	--
	-- Updates the current raid roster, adding new players and marking those who left.
	--
	function addon:UpdateRaidRoster()
		if not KRT_CurrentRaid then return end
		numRaidMembers = GetNumRaidMembers()
		if numRaidMembers == 0 then
			Raid:End()
			return
		end

		local realm = GetRealmName() or UNKNOWN
		KRT_Players[realm] = KRT_Players[realm] or {}
		local currentPlayers = {}

		for i = 1, numRaidMembers do
			local name, rank, subgroup, level, classL, class, _, online = GetRaidRosterInfo(i)
			if name then
				tinsert(currentPlayers, name)
				local playerInLog = false
				for _, p in pairs(KRT_Raids[KRT_CurrentRaid].players) do
					if p.name == name and p.leave == nil then
						playerInLog = true
						break
					end
				end

				if not playerInLog then
					local unitID = "raid" .. tostring(i)
					local raceL, race = UnitRace(unitID)
					local toRaid = {
						name     = name,
						rank     = rank,
						subgroup = subgroup,
						class    = class or "UNKNOWN",
						join     = Utils.GetCurrentTime(),
						leave    = nil,
						count    = 0, -- Initialize loot count
					}
					Raid:AddPlayer(toRaid)
				end

				if not KRT_Players[realm][name] then
					local unitID = "raid" .. tostring(i)
					local raceL, race = UnitRace(unitID)
					KRT_Players[realm][name] = {
						name   = name,
						level  = level,
						race   = race,
						raceL  = raceL,
						class  = class or "UNKNOWN",
						classL = classL,
						sex    = UnitSex(unitID)
					}
				end
			end
		end

		-- Mark players who have left
		for _, p in pairs(KRT_Raids[KRT_CurrentRaid].players) do
			if not Utils.checkEntry(currentPlayers, p.name) and p.leave == nil then
				p.leave = Utils.GetCurrentTime()
			end
		end
		Utils.unschedule(addon.UpdateRaidRoster)
	end

	--
	-- Creates a new raid log entry.
	--
	function Raid:Create(zoneName, raidSize)
		if KRT_CurrentRaid then
			self:End()
		end

		numRaidMembers = GetNumRaidMembers()
		if numRaidMembers == 0 then return end

		local realm = GetRealmName() or UNKNOWN
		KRT_Players[realm] = KRT_Players[realm] or {}
		local currentTime = Utils.GetCurrentTime()

		local raidInfo = {
			realm     = realm,
			zone      = zoneName,
			size      = raidSize,
			players   = {},
			bossKills = {},
			loot      = {},
			startTime = currentTime,
			changes   = {},
		}

		for i = 1, numRaidMembers do
			local name, rank, subgroup, level, classL, class = GetRaidRosterInfo(i)
			if name then
				local unitID = "raid" .. tostring(i)
				local raceL, race = UnitRace(unitID)
				tinsert(raidInfo.players, {
					name     = name,
					rank     = rank,
					subgroup = subgroup,
					class    = class or "UNKNOWN",
					join     = currentTime,
					leave    = nil,
					count    = 0, -- Initialize loot count
				})
				KRT_Players[realm][name] = {
					name   = name,
					level  = level,
					race   = race,
					raceL  = raceL,
					class  = class or "UNKNOWN",
					classL = classL,
					sex    = UnitSex(unitID),
				}
			end
		end

		tinsert(KRT_Raids, raidInfo)
		KRT_CurrentRaid = #KRT_Raids
		TriggerEvent("RaidCreate", KRT_CurrentRaid)
		Utils.schedule(3, addon.UpdateRaidRoster)
	end

	--
	-- Ends the current raid log entry, marking end time.
	--
	function Raid:End()
		if not KRT_CurrentRaid then return end
		Utils.unschedule(addon.Raid.UpdateRaidRoster)
		local currentTime = Utils.GetCurrentTime()

		for _, p in pairs(KRT_Raids[KRT_CurrentRaid].players) do
			if not p.leave then
				p.leave = currentTime
			end
		end
		KRT_Raids[KRT_CurrentRaid].endTime = currentTime
		KRT_CurrentRaid = nil
		KRT_LastBoss = nil
	end

	--
	-- Checks the current raid status and creates a new session if needed.
	--
	function Raid:Check(instanceName, instanceDiff)
		local newSize = (instanceDiff % 2 == 0) and 25 or 10

		if not KRT_CurrentRaid then
			Raid:Create(instanceName, newSize)
			return
		end

		local current = KRT_Raids[KRT_CurrentRaid]
		if current and (current.zone ~= instanceName or current.size ~= newSize) then
			addon:Print(L.StrNewRaidSessionChange)
			Raid:Create(instanceName, newSize)
		end
	end

	--
	-- Performs an initial raid check on player login.
	--
	function Raid:FirstCheck()
		Utils.unschedule(Raid.FirstCheck)
		if GetNumRaidMembers() == 0 then return end

		if KRT_CurrentRaid and Raid:CheckPlayer(unitName, KRT_CurrentRaid) then
			Utils.schedule(2, addon.UpdateRaidRoster)
			return
		end

		local instanceName, instanceType, instanceDiff = GetInstanceInfo()
		if instanceType == "raid" then
			Raid:Check(instanceName, instanceDiff)
		end
	end

	--
	-- Adds a player to the raid log.
	--
	function Raid:AddPlayer(playerData, raidNum)
		raidNum = raidNum or KRT_CurrentRaid
		if not raidNum or not playerData or not playerData.name then return end
		local players = self:GetPlayers(raidNum)
		local found = false

		for i, p in ipairs(players) do
			if playerData.name == p.name then
				playerData.count = playerData.count or p.count or 0 -- Preserve count
				KRT_Raids[raidNum].players[i] = playerData
				found = true
				break
			end
		end

		if not found then
			playerData.count = playerData.count or 0
			tinsert(KRT_Raids[raidNum].players, playerData)
		end
	end

	--
	-- Adds a boss kill to the active raid log.
	--
	function Raid:AddBoss(bossName, manDiff, raidNum)
		raidNum = raidNum or KRT_CurrentRaid
		if not raidNum or not bossName then return end

		local _, _, instanceDiff, _, _, dynDiff, isDyn = GetInstanceInfo()
		if manDiff then
			instanceDiff = (KRT_Raids[raidNum].size == 10) and 1 or 2
			if lower(manDiff) == "h" then instanceDiff = instanceDiff + 2 end
		elseif isDyn then
			instanceDiff = instanceDiff + (2 * dynDiff)
		end

		local onlinePlayers = {}
		for i = 1, GetNumRaidMembers() do
			local name, _, _, _, _, _, _, online = GetRaidRosterInfo(i)
			if online == 1 then
				tinsert(onlinePlayers, name)
			end
		end

		local killInfo = {
			name       = bossName,
			difficulty = instanceDiff,
			players    = onlinePlayers,
			date       = Utils.GetCurrentTime(),
			hash       = Utils.encode(raidNum .. "|" .. bossName .. "|" .. (KRT_LastBoss or "0"))
		}
		tinsert(KRT_Raids[raidNum].bossKills, killInfo)
		KRT_LastBoss = #KRT_Raids[raidNum].bossKills
	end

	--
	-- Adds a loot item to the active raid log.
	--
	function Raid:AddLoot(msg, rollType, rollValue)
		-- Master Loot
		local player, itemLink, itemCount = deformat(msg, LOOT_ITEM_MULTIPLE)
		if not player then
			itemCount = 1
			player, itemLink = deformat(msg, LOOT_ITEM)
		end
		if not player then
			player = unitName
			itemLink, itemCount = deformat(msg, msg, LOOT_ITEM_SELF_MULTIPLE)
		end
		if not itemLink then
			itemCount = 1
			itemLink = deformat(msg, LOOT_ITEM_SELF)
		end

		-- Other Loot Rolls
		if not player or not itemLink then
			itemCount = 1
			player, itemLink = deformat(msg, LOOT_ROLL_YOU_WON)
			if not itemLink then
				player = unitName
				itemLink = deformat(msg, LOOT_ROLL_YOU_WON)
			end
		end
		if not itemLink then return end

		local _, _, itemString = find(itemLink, "^|c%x+|H(.+)|h%[.*%]")
		local itemName, _, itemRarity, _, _, _, _, _, _, itemTexture = GetItemInfo(itemLink)
		local _, _, _, _, itemId = find(itemLink,
			"|?c?(%x*)|?H?([^:]*):?(%d+):?(%d*):?(%d*):?(%d*):?(%d*):?(%d*):?(%-?%d*):?(%-?%d*):?(%d*)|?h?%[?([^%[%]]*)%]?|?h?|?r?")
		itemId = tonumber(itemId)

		-- We don't proceed if lower than threshold or ignored.
		local lootThreshold = GetLootThreshold()
		if itemRarity and itemRarity < lootThreshold then return end
		if itemId and addon.ignoredItems[itemId] then return end

		if not KRT_LastBoss then
			self:AddBoss("_TrashMob_")
		end

		if not rollType then rollType = currentRollType end
		if not rollValue then rollValue = addon:HighestRoll() end

		local lootInfo = {
			itemId      = itemId,
			itemName    = itemName,
			itemString  = itemString,
			itemLink    = itemLink,
			itemRarity  = itemRarity,
			itemTexture = itemTexture,
			itemCount   = itemCount,
			looter      = player,
			rollType    = rollType,
			rollValue   = rollValue,
			bossNum     = KRT_LastBoss,
			time        = Utils.GetCurrentTime(),
		}
		tinsert(KRT_Raids[KRT_CurrentRaid].loot, lootInfo)
	end

	--------------------------------------------------------------------------
	-- Player Count API
	--------------------------------------------------------------------------

	function Raid:GetPlayerCount(name, raidNum)
		raidNum = raidNum or KRT_CurrentRaid
		local players = self:GetPlayers(raidNum)
		for _, p in ipairs(players) do
			if p.name == name then
				return p.count or 0
			end
		end
		return 0
	end

	function Raid:SetPlayerCount(name, value, raidNum)
		raidNum = raidNum or KRT_CurrentRaid

		if value < 0 then
			addon:PrintError(L.ErrPlayerCountBelowZero:format(name))
			return
		end

		if KRT_Raids[raidNum] and KRT_Raids[raidNum].players then
			for _, p in ipairs(KRT_Raids[raidNum].players) do
				if p.name == name then
					p.count = value
					return
				end
			end
		end
	end

	function Raid:IncrementPlayerCount(name, raidNum)
		if self:GetPlayerID(name, raidNum) == 0 then
			addon:PrintError(L.ErrCannotFindPlayer:format(name))
			return
		end
		local currentCount = self:GetPlayerCount(name, raidNum)
		self:SetPlayerCount(name, currentCount + 1, raidNum)
	end

	function Raid:DecrementPlayerCount(name, raidNum)
		if self:GetPlayerID(name, raidNum) == 0 then
			addon:PrintError(L.ErrCannotFindPlayer:format(name))
			return
		end
		local currentCount = self:GetPlayerCount(name, raidNum)
		if currentCount <= 0 then
			addon:PrintError(L.ErrPlayerCountBelowZero:format(name))
			return
		end
		self:SetPlayerCount(name, currentCount - 1, raidNum)
	end

	--------------------------------------------------------------------------
	-- Raid Functions
	--------------------------------------------------------------------------

	--
	-- Returns the number of members in the raid.
	--
	function addon:GetNumRaid()
		return numRaidMembers
	end

	--
	-- Returns raid size: 10 or 25.
	--
	function addon:GetRaidSize()
		if self:IsInRaid() then
			local diff = GetRaidDifficulty()
			return (diff == 1 or diff == 3) and 10 or 25
		end
		return 0
	end

	--
	-- Returns the RGB color values for a given class name.
	--
	do
		local colors = CUSTOM_CLASS_COLORS or RAID_CLASS_COLORS
		function addon:GetClassColor(name)
			name = (name == "DEATH KNIGHT") and "DEATHKNIGHT" or name
			if not colors[name] then
				return 1, 1, 1
			end
			local c = colors[name]
			return c.r, c.g, c.b
		end
	end

	--
	-- Checks if a raid log is expired (older than the weekly reset).
	--
	function Raid:IsExpired(raidID)
		raidID = raidID or KRT_CurrentRaid
		if not raidID or not KRT_Raids[raidID] then
			return true
		end

		local currentTime = Utils.GetCurrentTime()
		local startTime = KRT_Raids[raidID].startTime
		local validDuration = (currentTime + KRT_NextReset) - startTime

		return validDuration >= 604800 -- 7 days in seconds
	end

	--
	-- Retrieves all loot for a given raid and optional boss number.
	--
	function Raid:GetLoot(raidNum, bossNum)
		local items = {}
		raidNum = raidNum or KRT_CurrentRaid
		bossNum = tonumber(bossNum) or 0
		if not raidNum or not KRT_Raids[raidNum] then
			return items
		end

		local loot = KRT_Raids[raidNum].loot
		if bossNum <= 0 then
			-- Get all loot
			for k, v in ipairs(loot) do
				local info = v
				info.id = k
				tinsert(items, info)
			end
		elseif KRT_Raids[raidNum].bossKills[bossNum] then
			-- Get loot for a specific boss
			for k, v in ipairs(loot) do
				if v.bossNum == bossNum then
					local info = v
					info.id = k
					tinsert(items, info)
				end
			end
		end
		return items
	end

	--
	-- Retrieves the position of a specific loot item within the raid's loot table.
	--
	function Raid:GetLootID(itemID, raidNum, holderName)
		local loot = self:GetLoot(raidNum)
		holderName = holderName or unitName
		itemID = tonumber(itemID)
		for k, v in ipairs(loot) do
			if v.itemId == itemID and v.looter == holderName then
				return k
			end
		end
		return 0
	end

	--
	-- Retrieves all boss kills for a given raid.
	--
	function Raid:GetBosses(raidNum)
		local bosses = {}
		raidNum = raidNum or KRT_CurrentRaid
		if raidNum and KRT_Raids[raidNum] then
			for i, b in ipairs(KRT_Raids[raidNum].bossKills) do
				local info = {
					id         = i,
					difficulty = b.difficulty,
					time       = b.date,
					hash       = b.hash or "0",
				}
				if b.name == "_TrashMob_" then
					info.name = L.StrTrashMob
					info.mode = ""
				else
					info.name = b.name
					info.mode = (b.difficulty == 3 or b.difficulty == 4) and PLAYER_DIFFICULTY2 or PLAYER_DIFFICULTY1
				end
				tinsert(bosses, info)
			end
		end
		return bosses
	end

	--------------------------------------------------------------------------
	-- Player Functions
	--------------------------------------------------------------------------

	--
	-- Returns players from the raid log. Can be filtered by boss kill.
	--
	function Raid:GetPlayers(raidNum, bossNum)
		raidNum = raidNum or KRT_CurrentRaid
		local players = {}
		if raidNum and KRT_Raids[raidNum] then
			for k, v in ipairs(KRT_Raids[raidNum].players) do
				local info = v
				info.id = k
				tinsert(players, info)
			end

			if bossNum and KRT_Raids[raidNum].bossKills[bossNum] then
				local bossKillPlayers = {}
				local bossPlayersList = KRT_Raids[raidNum].bossKills[bossNum].players
				for _, p in ipairs(players) do
					if Utils.checkEntry(bossPlayersList, p.name) then
						tinsert(bossKillPlayers, p)
					end
				end
				return bossKillPlayers
			end
		end
		return players
	end

	--
	-- Checks if a player is in the raid log.
	--
	function Raid:CheckPlayer(name, raidNum)
		local players = self:GetPlayers(raidNum)
		if players then
			local cleanName = ucfirst(name:trim())
			for _, p in ipairs(players) do
				if cleanName == p.name then
					return true, p.name
				elseif strlen(cleanName) >= 5 and p.name:startsWith(cleanName) then
					return true, p.name
				end
			end
		end
		return false, name
	end

	--
	-- Returns the player's internal ID from the raid log.
	--
	function Raid:GetPlayerID(name, raidNum)
		raidNum = raidNum or KRT_CurrentRaid
		if raidNum and KRT_Raids[raidNum] then
			name = name or unitName
			for i, p in ipairs(KRT_Raids[raidNum].players) do
				if p.name == name then
					return i
				end
			end
		end
		return 0
	end

	--
	-- Gets a player's name by their internal ID.
	--
	function Raid:GetPlayerName(id, raidNum)
		raidNum = raidNum or addon.Logger.selectedRaid or KRT_CurrentRaid
		if raidNum and KRT_Raids[raidNum] then
			for k, p in ipairs(KRT_Raids[raidNum].players) do
				if k == id then
					return p.name
				end
			end
		end
	end

	--
	-- Returns a table of items looted by the selected player.
	--
	function Raid:GetPlayerLoot(name, raidNum, bossNum)
		local items = {}
		local loot = self:GetLoot(raidNum, bossNum)
		if type(name) == "number" then
			name = self:GetPlayerName(name)
		end
		for k, v in ipairs(loot) do
			if v.looter == name then
				local info = v
				info.id = k
				tinsert(items, info)
			end
		end
		return items
	end

	--
	-- Gets a player's rank.
	--
	function addon:GetPlayerRank(name, raidNum)
		local rank = 0
		name = name or unitName
		local players = Raid:GetPlayers(raidNum)

		if next(players) == nil then
			if GetNumRaidMembers() > 0 then
				numRaidMembers = GetNumRaidMembers()
				for i = 1, numRaidMembers do
					local pName, pRank = GetRaidRosterInfo(i)
					if pName == name then
						rank = pRank
						break
					end
				end
			end
		else
			for _, p in ipairs(players) do
				if p.name == name then
					rank = p.rank or 0
					break
				end
			end
		end
		return rank
	end

	--
	-- Gets a player's class from the saved players database.
	--
	function addon:GetPlayerClass(name)
		local class = "UNKNOWN"
		local realm = GetRealmName() or UNKNOWN
		local resolvedName = name or unitName
		if KRT_Players[realm] and KRT_Players[realm][resolvedName] then
			class = KRT_Players[realm][resolvedName].class or "UNKNOWN"
		end
		return class
	end

	--
	-- Gets a player's unit ID (e.g., "raid1").
	--
	function addon:GetUnitID(name)
		local players = Raid:GetPlayers()
		if players then
			for i, p in ipairs(players) do
				if p.name == name then
					return "raid" .. tostring(i)
				end
			end
		end
		return "none"
	end

	--------------------------------------------------------------------------
	-- Raid & Loot Status Checks
	--------------------------------------------------------------------------

	--
	-- Checks if the player is in a party.
	--
	function addon:IsInParty()
		return (GetNumPartyMembers() > 0) and (GetNumRaidMembers() == 0)
	end

	--
	-- Checks if the player is in a raid.
	--
	function addon:IsInRaid()
		return (inRaid == true or GetNumRaidMembers() > 0)
	end

	--
	-- Checks if the group is using the Master Looter system.
	--
	function addon:IsMasterLoot()
		local method = select(1, GetLootMethod())
		return (method == "master")
	end

	--
	-- Checks if the player is the Master Looter.
	--
	function addon:IsMasterLooter()
		local _, partyID = GetLootMethod()
		return (partyID and partyID == 0)
	end

	--
	-- Clears all raid target icons.
	--
	function addon:ClearRaidIcons()
		for i = 1, GetNumRaidMembers() do
			SetRaidTarget("raid" .. tostring(i), 0)
		end
	end
end

---============================================================================
-- Chat Output Helpers
---============================================================================
do
	local OUTPUT_FORMAT = "|cfff58cba%s|r: %s"
	local CHAT_PREFIX_SHORT = "KRT"

	--
	-- Prepares the final output string with a prefix.
	--
	local function PreparePrint(text, prefix)
		prefix = prefix or CHAT_PREFIX_SHORT
		return format(OUTPUT_FORMAT, prefix, tostring(text))
	end

	--
	-- Prints a default message to the chat frame.
	--
	function addon:Print(text, prefix)
		local msg = PreparePrint(text, prefix)
		return Utils.print(msg)
	end

	--
	-- Prints a green success message.
	--
	function addon:PrintSuccess(text, prefix)
		local msg = PreparePrint(text, prefix)
		return Utils.print_green(msg)
	end

	--
	-- Prints a red error message.
	--
	function addon:PrintError(text, prefix)
		local msg = PreparePrint(text, prefix)
		return Utils.print_red(msg)
	end

	--
	-- Prints an orange warning message.
	--
	function addon:PrintWarning(text, prefix)
		local msg = PreparePrint(text, prefix)
		return Utils.print_orange(msg)
	end

	--
	-- Prints a blue info message.
	--
	function addon:PrintInfo(text, prefix)
		local msg = PreparePrint(text, prefix)
		return Utils.print_blue(msg)
	end

	--
	-- Sends an announcement to the appropriate channel (Raid, Party, etc.).
	--
	function addon:Announce(text, channel)
		if not channel then
			if self:IsInRaid() then
				-- Check for countdown messages to determine channel
				local countdownTicPattern = L.ChatCountdownTic:gsub("%%d", "%%d+")
				local isCountdownMessage = text:find(countdownTicPattern) or text:find(L.ChatCountdownEnd)
				local isLeaderOrOfficer = IsRaidLeader() or IsRaidOfficer()

				if isCountdownMessage then
					if addon.options.countdownSimpleRaidMsg then
						channel = "RAID"
					elseif addon.options.useRaidWarning and isLeaderOrOfficer then
						channel = "RAID_WARNING"
					else
						channel = "RAID" -- Fallback
					end
				else
					if addon.options.useRaidWarning and isLeaderOrOfficer then
						channel = "RAID_WARNING"
					else
						channel = "RAID" -- Fallback
					end
				end
			elseif self:IsInParty() then
				channel = "PARTY"
			else
				channel = "SAY" -- Fallback for solo
			end
		end
		SendChatMessage(tostring(text), channel)
	end
end

---============================================================================
-- Minimap Button Module
---============================================================================
do
	addon.Minimap = {}
	local Minimap = addon.Minimap

	-- Local variables
	local addonMenu
	local dragMode

	-- Cached math functions
	local abs, sqrt = math.abs, math.sqrt

	--
	-- Initializes and opens the right-click menu for the minimap button.
	--
	local function OpenMenu()
		addonMenu = addonMenu or CreateFrame("Frame", "KRTMenu", UIParent, "UIDropDownMenuTemplate")
		addonMenu.displayMode = "MENU"
		addonMenu.initialize = function(self, level)
			if not level then return end
			local info = {}
			if level == 1 then
				-- Toggle master loot frame
				info.text = MASTER_LOOTER
				info.notCheckable = 1
				info.func = function() addon.Master:Toggle() end
				UIDropDownMenu_AddButton(info, level)

				-- Toggle raid warnings frame
				info.text = RAID_WARNING
				info.notCheckable = 1
				info.func = function() addon.Warnings:Toggle() end
				UIDropDownMenu_AddButton(info, level)

				-- Toggle loot history frame
				info.text = L.StrLootHistory
				info.notCheckable = 1
				info.func = function() addon.Logger:Toggle() end
				UIDropDownMenu_AddButton(info, level)

				-- Separator
				info = { disabled = true, notCheckable = true }
				UIDropDownMenu_AddButton(info, level)

				-- Clear raid icons
				info = { text = L.StrClearIcons, notCheckable = true }
				info.func = function() addon:ClearRaidIcons() end
				UIDropDownMenu_AddButton(info, level)

				-- Separator
				info = { disabled = true, notCheckable = true }
				UIDropDownMenu_AddButton(info, level)

				-- MS Changes Header
				info = { isTitle = true, text = L.StrMSChanges, notCheckable = true }
				UIDropDownMenu_AddButton(info, level)

				-- Toggle MS Changes frame
				info = { text = L.BtnConfigure, notCheckable = true }
				info.func = function() addon.Changes:Toggle() end
				UIDropDownMenu_AddButton(info, level)

				-- Ask for MS changes
				info = { text = L.BtnDemand, notCheckable = true }
				info.func = function() addon.Changes:Demand() end
				UIDropDownMenu_AddButton(info, level)

				-- Spam MS changes
				info = { text = CHAT_ANNOUNCE, notCheckable = true }
				info.func = function() addon.Changes:Announce() end
				UIDropDownMenu_AddButton(info, level)

				-- Separator
				info = { disabled = true, notCheckable = true }
				UIDropDownMenu_AddButton(info, level)

				-- Toggle LFM Spammer frame
				info = { text = L.StrLFMSpam, notCheckable = true }
				info.func = function() addon.Spammer:Toggle() end
				UIDropDownMenu_AddButton(info, level)
			end
		end
		ToggleDropDownMenu(1, nil, addonMenu, KRT_MINIMAP_GUI, 0, 0)
	end

	--
	-- Moves the minimap button while dragging.
	--
	local function MoveButton(self)
		local centerX, centerY = Minimap:GetCenter()
		local x, y = GetCursorPosition()
		x, y = x / self:GetEffectiveScale() - centerX, y / self:GetEffectiveScale() - centerY

		if dragMode == "free" then
			-- Free drag mode
			self:ClearAllPoints()
			self:SetPoint("CENTER", x, y)
		else
			-- Circular drag mode
			centerX, centerY = abs(x), abs(y)
			centerX = (centerX / sqrt(centerX ^ 2 + centerY ^ 2)) * 80
			centerY = (centerY / sqrt(centerX ^ 2 + centerY ^ 2)) * 80
			centerX = x < 0 and -centerX or centerX
			centerY = y < 0 and -centerY or centerY
			self:ClearAllPoints()
			self:SetPoint("CENTER", centerX, centerY)
		end
	end

	--
	-- OnLoad handler for the minimap button.
	--
	function Minimap:OnLoad(btn)
		if not btn then return end
		KRT_MINIMAP_GUI:SetUserPlaced(true)
		KRT_MINIMAP_GUI:RegisterForClicks("LeftButtonUp", "RightButtonUp")
		KRT_MINIMAP_GUI:SetScript("OnMouseDown", function(self, button)
			if IsAltKeyDown() then
				dragMode = "free"
				self:SetScript("OnUpdate", MoveButton)
			elseif IsShiftKeyDown() then
				dragMode = nil
				self:SetScript("OnUpdate", MoveButton)
			end
		end)
		KRT_MINIMAP_GUI:SetScript("OnMouseUp", function(self)
			self:SetScript("OnUpdate", nil)
		end)
		KRT_MINIMAP_GUI:SetScript("OnClick", function(self, button, down)
			if IsShiftKeyDown() or IsAltKeyDown() then return end
			if button == "RightButton" then
				addon.Config:Toggle()
			elseif button == "LeftButton" then
				OpenMenu()
			end
		end)
		KRT_MINIMAP_GUI:SetScript("OnEnter", function(self)
			GameTooltip_SetDefaultAnchor(GameTooltip, self)
			GameTooltip:SetText("|cfff58cbaKader|r |caad4af37Raid Tools|r")
			GameTooltip:AddLine(L.StrMinimapLClick, 1, 1, 1)
			GameTooltip:AddLine(L.StrMinimapRClick, 1, 1, 1)
			GameTooltip:AddLine(L.StrMinimapSClick, 1, 1, 1)
			GameTooltip:AddLine(L.StrMinimapAClick, 1, 1, 1)
			GameTooltip:Show()
		end)
		KRT_MINIMAP_GUI:SetScript("OnLeave", function(self)
			GameTooltip:Hide()
		end)
	end

	--
	-- Toggles the visibility of the minimap button.
	--
	function addon:ToggleMinimapButton()
		self.options.minimapButton = not self.options.minimapButton
		if self.options.minimapButton then
			KRT_MINIMAP_GUI:Show()
		else
			KRT_MINIMAP_GUI:Hide()
		end
	end

	--
	-- Hides the minimap button.
	--
	function addon:HideMinimapButton()
		return KRT_MINIMAP_GUI:Hide()
	end
end

---============================================================================
-- Rolls Helpers Module
-- Manages roll tracking, sorting, and winner determination.
---============================================================================
do
	addon.Rolls = {}
	local Rolls = addon.Rolls
	local frameName

	-- Roll state variables
	local isRecording, canRoll, warned = false, true, false
	local hasRolled = false
	local playerRollTracker, rollsTable, rerolledPlayers, itemRollTracker = {}, {}, {}, {}
	local selectedPlayer = nil

	--
	-- Sorts the rollsTable either ascending or descending.
	--
	local function SortRolls()
		if rollsTable and #rollsTable > 0 then
			table.sort(rollsTable, function(a, b)
				if addon.options.sortAscending then
					return a.roll < b.roll
				end
				return a.roll > b.roll
			end)
			winner = rollsTable[1].name
			addon:Debug("DEBUG", "Sorted rolls; current winner: %s with roll: %d", winner, rollsTable[1].roll)
		end
	end

	--
	-- Adds a player's roll to the tracking tables.
	--
	local function AddRoll(name, roll, itemId)
		roll = tonumber(roll)
		rollsCount = rollsCount + 1
		rollsTable[rollsCount] = { name = name, roll = roll, itemId = itemId }
		addon:Debug("DEBUG", "AddRoll: name=%s, roll=%d, itemId=%s", tostring(name), roll, tostring(itemId))

		if itemId then
			itemRollTracker[itemId] = itemRollTracker[itemId] or {}
			itemRollTracker[itemId][name] = (itemRollTracker[itemId][name] or 0) + 1
			addon:Debug("DEBUG", "Updated itemRollTracker: itemId=%d, player=%s, count=%d", itemId, name,
				itemRollTracker[itemId][name])
		end

		TriggerEvent("AddRoll", name, roll)
		SortRolls()

		-- Auto-select winner if none is manually selected
		if not selectedPlayer then
			local resolvedItemId = itemId or addon:GetCurrentRollItemID()
			if currentRollType == ROLL_TYPES.RESERVED then
				local topRoll = -1
				for _, entry in ipairs(rollsTable) do
					if addon:IsReserved(resolvedItemId, entry.name) and entry.roll > topRoll then
						topRoll = entry.roll
						selectedPlayer = entry.name
					end
				end
				addon:Debug("DEBUG", "Reserved roll: auto-selected player=%s", tostring(selectedPlayer))
			else
				selectedPlayer = winner
				addon:Debug("DEBUG", "Free roll: auto-selected player=%s", tostring(selectedPlayer))
			end
		end
		addon:FetchRolls()
	end

	--
	-- Initiates a /roll 1-100 for the player.
	--
	function addon:Roll()
		local itemId = self:GetCurrentRollItemID()
		if not itemId then return end

		local name = unitName
		local allowedRolls = 1
		if currentRollType == ROLL_TYPES.RESERVED then
			allowedRolls = addon.Reserves:GetReserveCountForItem(itemId, name)
		end

		playerRollTracker[itemId] = playerRollTracker[itemId] or 0
		if playerRollTracker[itemId] >= allowedRolls then
			addon:Debug("DEBUG", "Roll blocked for %s (max %d rolls reached for itemId=%d)", name, allowedRolls, itemId)
			addon:Print(L.ChatOnlyRollOnce)
			return
		end

		addon:Debug("DEBUG", "Rolling for itemId=%d (player=%s)", itemId, name)
		RandomRoll(1, 100)
		playerRollTracker[itemId] = playerRollTracker[itemId] + 1
	end

	--
	-- Returns the current roll session state.
	--
	function addon:RollStatus()
		addon:Debug("DEBUG", "RollStatus queried: type=%s, record=%s, canRoll=%s, rolled=%s", tostring(currentRollType),
			tostring(isRecording), tostring(canRoll), tostring(hasRolled))
		return currentRollType, isRecording, canRoll, hasRolled
	end

	--
	-- Enables or disables the recording of rolls.
	--
	function addon:RecordRolls(shouldRecord)
		isRecording, canRoll = shouldRecord, shouldRecord
		addon:Debug("DEBUG", "RecordRolls: %s", tostring(shouldRecord))
	end

	--
	-- Intercepts system messages to detect player rolls.
	--
	function addon:CHAT_MSG_SYSTEM(msg)
		if not msg or not isRecording then return end
		local player, roll, min, max = deformat(msg, RANDOM_ROLL_RESULT)
		if player and roll and min == 1 and max == 100 then
			addon:Debug("DEBUG", "Detected roll message: %s rolled %d (range %d-%d)", player, roll, min, max)

			if not canRoll then
				if not warned then
					self:Announce(L.ChatCountdownBlock)
					warned = true
					addon:Debug("DEBUG", "Roll blocked: countdown active")
				end
				return
			end

			local itemId = self:GetCurrentRollItemID()
			if not itemId or lootCount == 0 then
				addon:PrintError("Item ID missing or loot table not ready – roll will be ignored.")
				addon:Debug("DEBUG", "Roll ignored: missing itemId or lootCount = 0")
				return
			end

			local allowedRolls = 1
			if currentRollType == ROLL_TYPES.RESERVED then
				allowedRolls = math.max(1, addon.Reserves:GetReserveCountForItem(itemId, player))
			end

			itemRollTracker[itemId] = itemRollTracker[itemId] or {}
			local rollCount = itemRollTracker[itemId][player] or 0

			if rollCount >= allowedRolls then
				if not Utils.checkEntry(rerolledPlayers, player) then
					Utils.whisper(player, L.ChatOnlyRollOnce)
					tinsert(rerolledPlayers, player)
					addon:Debug("DEBUG", "Roll denied: %s exceeded allowed rolls for item %d", player, itemId)
				end
				return
			end

			addon:Debug("DEBUG", "Roll accepted: %s (%d/%d) for item %d", player, rollCount + 1, allowedRolls, itemId)
			AddRoll(player, roll, itemId)
		end
	end

	--
	-- Returns the current table of rolls.
	--
	function addon:GetRolls()
		addon:Debug("DEBUG", "GetRolls called; count: %d", #rollsTable)
		return rollsTable
	end

	--
	-- Sets the flag indicating the player has rolled.
	--
	function addon:SetRolled()
		hasRolled = true
		addon:Debug("DEBUG", "SetRolled: hasRolled flag set to true")
	end

	--
	-- Checks if a player has already used all their rolls for an item.
	--
	function addon:DidRoll(itemId, name)
		if not itemId then
			for _, entry in ipairs(rollsTable) do
				if entry.name == name then
					addon:Debug("DEBUG", "DidRoll: %s has rolled (no itemId specified)", name)
					return true
				end
			end
			addon:Debug("DEBUG", "DidRoll: %s has NOT rolled (no itemId specified)", name)
			return false
		end

		itemRollTracker[itemId] = itemRollTracker[itemId] or {}
		local rollCount = itemRollTracker[itemId][name] or 0
		local allowedRolls = (currentRollType == ROLL_TYPES.RESERVED) and
			addon.Reserves:GetReserveCountForItem(itemId, name) or 1
		local result = rollCount >= allowedRolls
		addon:Debug("DEBUG", "DidRoll: name=%s, itemId=%d, used=%d, allowed=%d, result=%s", name, itemId, rollCount,
			allowedRolls, tostring(result))
		return result
	end

	--
	-- Returns the highest roll value from the current winner.
	--
	function addon:HighestRoll()
		for _, entry in ipairs(rollsTable) do
			if entry.name == winner then
				addon:Debug("DEBUG", "HighestRoll: %s rolled %d", winner, entry.roll)
				return entry.roll
			end
		end
		return 0
	end

	--
	-- Clears all roll-related state and UI elements.
	--
	function addon:ClearRolls(keepRecording)
		frameName = frameName or self:GetFrameName()
		if not frameName then return end

		twipe(rollsTable)
		twipe(rerolledPlayers)
		twipe(itemRollTracker)
		twipe(playerRollTracker)

		hasRolled, warned, rollsCount = false, false, 0
		selectedPlayer = nil

		if keepRecording == false then
			isRecording = false
		end

		local i = 1
		local btn = _G[frameName .. "PlayerBtn" .. i]
		while btn do
			btn:Hide()
			i = i + 1
			btn = _G[frameName .. "PlayerBtn" .. i]
		end

		self:ClearRaidIcons()
	end

	--
	-- Gets the item ID of the item currently being rolled for.
	--
	function addon:GetCurrentRollItemID()
		if GetItemIndex and GetItem then
			local index = GetItemIndex() or 1
			local item = GetItem(index)
			if item and item.itemLink then
				local itemId = tonumber(match(item.itemLink, "item:(%d+)"))
				addon:Debug("DEBUG", "GetCurrentRollItemID: Found itemId %d", itemId or "nil")
				return itemId
			end
		end
		addon:Debug("DEBUG", "GetCurrentRollItemID: No itemLink found.")
		return nil
	end

	--
	-- Validates if a player can still roll for an item.
	--
	function addon:IsValidRoll(itemId, name)
		itemRollTracker[itemId] = itemRollTracker[itemId] or {}
		local rollCount = itemRollTracker[itemId][name] or 0
		local allowedRolls = (currentRollType == ROLL_TYPES.RESERVED) and
			addon.Reserves:GetReserveCountForItem(itemId, name) or 1
		local result = rollCount < allowedRolls
		addon:Debug("DEBUG", "IsValidRoll: %s on item %d: used=%d, allowed=%d, valid=%s", name, itemId, rollCount,
			allowedRolls, tostring(result))
		return result
	end

	--
	-- Checks if a player has reserved the specified item.
	--
	function addon:IsReserved(itemId, name)
		local reserved = addon.Reserves:GetReserveCountForItem(itemId, name) > 0
		addon:Debug("DEBUG", "IsReserved: %s for item %d => %s", name, itemId, tostring(reserved))
		return reserved
	end

	--
	-- Gets the number of reserves a player has used for an item.
	--
	function addon:GetUsedReserveCount(itemId, name)
		itemRollTracker[itemId] = itemRollTracker[itemId] or {}
		local count = itemRollTracker[itemId][name] or 0
		addon:Debug("DEBUG", "GetUsedReserveCount: %s on item %d => %d", name, itemId, count)
		return count
	end

	--
	-- Gets the total number of reserves a player has for an item.
	--
	function addon:GetAllowedReserves(itemId, name)
		local count = addon.Reserves:GetReserveCountForItem(itemId, name)
		addon:Debug("DEBUG", "GetAllowedReserves: %s for item %d => %d", name, itemId, count)
		return count
	end

	--
	-- Rebuilds the roll list UI and marks the top roller or selected winner.
	--
	function addon:FetchRolls()
		frameName = frameName or addon:GetFrameName()
		if not frameName then return end
		addon:Debug("DEBUG", "FetchRolls called; frameName: %s", frameName)

		local scrollFrame = _G[frameName .. "ScrollFrame"]
		local scrollChild = _G[frameName .. "ScrollFrameScrollChild"]
		scrollChild:SetHeight(scrollFrame:GetHeight())
		scrollChild:SetWidth(scrollFrame:GetWidth())

		local itemId = self:GetCurrentRollItemID()
		local isSR = currentRollType == ROLL_TYPES.RESERVED
		addon:Debug("DEBUG", "Current itemId: %s, SR mode: %s", tostring(itemId), tostring(isSR))

		-- Determine who gets the star icon
		local starTarget = selectedPlayer
		if not starTarget then
			if isSR then
				local topRoll = -1
				for _, entry in ipairs(rollsTable) do
					if addon:IsReserved(itemId, entry.name) and entry.roll > topRoll then
						topRoll = entry.roll
						starTarget = entry.name
					end
				end
				addon:Debug("DEBUG", "Top SR roller identified as: %s", tostring(starTarget))
			else
				starTarget = winner
				addon:Debug("DEBUG", "Top roller identified as: %s", tostring(starTarget))
			end
		end

		local starShown = false
		local totalHeight = 0
		for i = 1, rollsCount do
			local entry = rollsTable[i]
			local name, roll = entry.name, entry.roll
			local btnName = frameName .. "PlayerBtn" .. i
			local btn = _G[btnName] or CreateFrame("Button", btnName, scrollChild, "KRTSelectPlayerTemplate")

			btn:SetID(i)
			btn:Show()

			if not btn.selectedBackground then
				btn.selectedBackground = btn:CreateTexture(nil, "ARTWORK")
				btn.selectedBackground:SetAllPoints()
				btn.selectedBackground:SetTexture(1, 0.8, 0, 0.1)
				btn.selectedBackground:Hide()
			end

			local nameStr, rollStr, star = _G[btnName .. "Name"], _G[btnName .. "Roll"], _G[btnName .. "Star"]

			if nameStr and nameStr.SetVertexColor then
				if isSR and self:IsReserved(itemId, name) then
					nameStr:SetVertexColor(0.4, 0.6, 1.0) -- Special color for reserved players
				else
					local _, class = UnitClass(name)
					local r, g, b = self:GetClassColor(class and class:upper() or "UNKNOWN")
					nameStr:SetVertexColor(r, g, b)
				end
			end

			if selectedPlayer == name then
				nameStr:SetText("> " .. name .. " <")
				btn.selectedBackground:Show()
			else
				nameStr:SetText(name)
				btn.selectedBackground:Hide()
			end

			if isSR and self:IsReserved(itemId, name) then
				local allowed = self:GetAllowedReserves(itemId, name)
				local used = self:GetUsedReserveCount(itemId, name)
				rollStr:SetText(allowed > 1 and format("%d (%d/%d)", roll, used, allowed) or tostring(roll))
			else
				rollStr:SetText(roll)
			end

			local showStar = not starShown and name == starTarget
			Utils.showHide(star, showStar)
			if showStar then
				addon:Debug("DEBUG", "Star assigned to: %s", name)
				starShown = true
			end

			btn:SetScript("OnClick", function()
				selectedPlayer = name
				addon:FetchRolls()
			end)

			btn:SetPoint("TOPLEFT", scrollChild, "TOPLEFT", 0, -totalHeight)
			btn:SetPoint("RIGHT", scrollChild, "RIGHT", 0, 0)
			totalHeight = totalHeight + btn:GetHeight()
		end

		if totalHeight > scrollChild:GetHeight() then
			scrollChild:SetHeight(totalHeight)
		end
		addon:Debug("DEBUG", "FetchRolls completed. Total entries: %d", rollsCount)
	end
end

---============================================================================
-- Loot Helpers Module
-- Manages the loot window items (fetching from loot/inventory).
---============================================================================
do
	addon.Loot = {}
	local Loot = addon.Loot
	local frameName

	local lootTable = {}
	local currentItemIndex = 0

	--
	-- Fetches items from the currently open loot window.
	--
	function addon:FetchLoot()
		local oldItemLink
		if lootCount >= 1 then
			oldItemLink = GetItemLink(currentItemIndex)
		end

		isLootOpen = true
		isFromInventory = false
		self:ClearLoot()

		for i = 1, GetNumLootItems() do
			if LootSlotIsItem(i) then
				local itemLink = GetLootSlotLink(i)
				if GetItemFamily(itemLink) ~= 64 then -- Ignore enchanting materials
					self:AddItem(itemLink)
				end
			end
		end

		currentItemIndex = 1
		if oldItemLink then
			for i = 1, lootCount do
				if oldItemLink == GetItemLink(i) then
					currentItemIndex = i
					break
				end
			end
		end
		self:PrepareItem()
	end

	--
	-- Adds an item to the loot table.
	--
	function addon:AddItem(itemLink)
		local itemName, _, itemRarity, _, _, _, _, _, _, itemTexture = GetItemInfo(itemLink)

		-- Defer if item info isn't cached yet
		if not itemName or not itemRarity then
			GameTooltip:SetOwner(UIParent, "ANCHOR_NONE")
			GameTooltip:SetHyperlink(itemLink)
			GameTooltip:Hide()
			addon:Debug("DEBUG", "Item info not available yet, deferring add.")
			return
		end

		if not isFromInventory then
			local lootThreshold = GetLootThreshold()
			if itemRarity < lootThreshold then return end
			lootCount = lootCount + 1
		else
			lootCount = 1
			currentItemIndex = 1
		end

		lootTable[lootCount] = {
			itemName    = itemName,
			itemColor   = ITEM_QUALITY_COLORS[itemRarity + 1],
			itemLink    = itemLink,
			itemTexture = itemTexture
		}
		TriggerEvent("AddItem", itemLink)
	end

	--
	-- Prepares the currently selected item for display.
	--
	function addon:PrepareItem()
		if ItemExists(currentItemIndex) then
			self:SetItem(lootTable[currentItemIndex])
		end
	end

	--
	-- Sets the main item display in the UI.
	--
	function addon:SetItem(item)
		if item.itemName and item.itemLink and item.itemTexture and item.itemColor then
			frameName = frameName or self:GetFrameName()
			if not frameName then return end

			local currentItemLink = _G[frameName .. "Name"]
			currentItemLink:SetText("|c" .. item.itemColor .. item.itemName .. "|r")

			local currentItemBtn = _G[frameName .. "ItemBtn"]
			currentItemBtn:SetNormalTexture(item.itemTexture)

			if self.options.showTooltips then
				currentItemBtn.tooltip_item = item.itemLink
				self:SetTooltip(currentItemBtn, nil, "ANCHOR_CURSOR")
			end
			TriggerEvent("SetItem", item.itemLink)
		end
	end

	--
	-- Selects an item from the loot list by its index.
	--
	function addon:SelectItem(index)
		if ItemExists(index) then
			currentItemIndex = index
			self:PrepareItem()
		end
	end

	--
	-- Clears all loot from the table and resets the UI display.
	--
	function addon:ClearLoot()
		twipe(lootTable)
		lootCount = 0
		frameName = frameName or self:GetFrameName()
		if not frameName then return end

		_G[frameName .. "Name"]:SetText(L.StrNoItemSelected)
		_G[frameName .. "ItemBtn"]:SetNormalTexture("Interface\\PaperDoll\\UI-Backpack-EmptySlot")
		if frameName == UIMaster:GetName() then
			local itemCountInput = _G[frameName .. "ItemCount"]
			itemCountInput:SetText("")
			itemCountInput:ClearFocus()
			itemCountInput:Hide()
		end
	end

	--
	-- Returns the index of the currently selected item.
	--
	function GetItemIndex()
		return currentItemIndex
	end

	--
	-- Returns the table for the currently selected item.
	--
	function GetItem(index)
		index = index or currentItemIndex
		return lootTable[index]
	end

	--
	-- Returns the name of the currently selected item.
	--
	function GetItemName(index)
		index = index or currentItemIndex
		return lootTable[index] and lootTable[index].itemName
	end

	--
	-- Returns the link of the currently selected item.
	--
	function GetItemLink(index)
		index = index or currentItemIndex
		return lootTable[index] and lootTable[index].itemLink
	end

	--
	-- Returns the texture of the currently selected item.
	--
	function GetItemTexture(index)
		index = index or currentItemIndex
		return lootTable[index] and lootTable[index].itemTexture
	end

	--
	-- Checks if a loot item exists at the given index.
	--
	function ItemExists(index)
		index = index or currentItemIndex
		return (lootTable[index] ~= nil)
	end

	--
	-- Checks if an item in the player's bags is soulbound.
	--
	function ItemIsSoulbound(bag, slot)
		local tip = KRT_FakeTooltip or CreateFrame("GameTooltip", "KRT_FakeTooltip", nil, "GameTooltipTemplate")
		KRT_FakeTooltip = tip
		tip:SetOwner(UIParent, "ANCHOR_NONE")
		tip:SetBagItem(bag, slot)
		tip:Show()

		for i = tip:NumLines(), 1, -1 do
			local lineText = _G["KRT_FakeTooltipTextLeft" .. i]:GetText()
			if deformat(lineText, BIND_TRADE_TIME_REMAINING) ~= nil then
				tip:Hide()
				return false
			elseif lineText == ITEM_SOULBOUND then
				tip:Hide()
				return true
			end
		end

		tip:Hide()
		return false
	end
end
-- Part 2 of 2 --

---============================================================================
-- Master Looter Frame Module
---============================================================================
do
	addon.Master = {}
	local Master = addon.Master
	local frameName

	-- State variables
	local isLocalized = false
	local updateInterval = 0.05
	local dropDownsInitialized = false
	local isCountdownRunning = false
	local countdownStart, countdownPos = 0, 0
	local screenshotWarned = false
	local announced = false

	-- UI Elements
	local selectionFrame
	local dropDownFrameHolder, dropDownFrameBanker, dropDownFrameDisenchanter
	local dropDownData, dropDownGroupData = {}, {}

	-- Local functions
	local LocalizeUIFrame, UpdateUIFrame
	local InitializeDropDowns, PrepareDropDowns, UpdateDropDowns
	local AssignItem, TradeItem

	--
	-- OnLoad handler for the Master Looter frame.
	--
	function Master:OnLoad(frame)
		if not frame then return end
		UIMaster = frame
		frameName = frame:GetName()
		frame:RegisterForDrag("LeftButton")
		frame:SetScript("OnUpdate", UpdateUIFrame)
		frame:SetScript("OnHide", function()
			if selectionFrame then selectionFrame:Hide() end
		end)
	end

	--
	-- Toggles the visibility of the Master Looter frame.
	--
	function Master:Toggle()
		Utils.toggle(UIMaster)
	end

	--
	-- Hides the Master Looter frame.
	--
	function Master:Hide()
		if UIMaster and UIMaster:IsShown() then
			UIMaster:Hide()
		end
	end

	--
	-- Button: Select/Remove Item
	--
	function Master:BtnSelectItem()
		if lootCount <= 0 then return end
		if isFromInventory then
			addon:ClearLoot()
			addon:ClearRolls()
			addon:RecordRolls(false)
			announced = false
			isFromInventory = false
			if isLootOpen then addon:FetchLoot() end
		elseif selectionFrame then
			selectionFrame:SetShown(not selectionFrame:IsVisible())
		end
	end

	--
	-- Button: Spam Loot Links or Do Ready Check
	--
	function Master:BtnSpamLoot()
		if lootCount <= 0 then return end
		if isFromInventory then
			addon:Announce(L.ChatReadyCheck)
			DoReadyCheck()
		else
			addon:Announce(L.ChatSpamLoot, "RAID")
			for i = 1, lootCount do
				local itemLink = GetItemLink(i)
				if itemLink then
					addon:Announce(i .. ". " .. itemLink, "RAID")
				end
			end
		end
	end

	--
	-- Button: Open Reserves List
	--
	function Master:BtnOpenReserves()
		addon.Reserves:ShowWindow()
	end

	--
	-- Button: Import Reserves
	--
	function Master:BtnImportReserves()
		addon.Reserves:ShowImportBox()
	end

	--
	-- Generic function to announce a roll for the current item.
	--
	local function AnnounceRoll(rollType, chatMsgKey)
		if lootCount < 1 then return end
		announced = false
		currentRollType = rollType
		addon:ClearRolls()
		addon:RecordRolls(true)

		local itemLink = GetItemLink()
		local itemID = tonumber(match(itemLink or "", "item:(%d+)"))
		local message = ""
		local sortSuffix = addon.options.sortAscending and "Low" or "High"

		if rollType == ROLL_TYPES.RESERVED and addon.Reserves and addon.Reserves.FormatReservedPlayersLine then
			local srList = addon.Reserves:FormatReservedPlayersLine(itemID)
			local chatKey = itemCount > 1 and (chatMsgKey .. "Multiple" .. sortSuffix) or (chatMsgKey .. sortSuffix)
			message = L[chatKey]:format(srList, itemLink, itemCount)
		else
			local chatKey = itemCount > 1 and (chatMsgKey .. "Multiple" .. sortSuffix) or (chatMsgKey .. sortSuffix)
			message = L[chatKey]:format(itemLink, itemCount)
		end

		addon:Announce(message)
		_G[frameName .. "ItemCount"]:ClearFocus()
		currentRollItem = addon.Raid:GetLootID(itemID)
	end

	-- Roll Buttons
	function Master:BtnMS() AnnounceRoll(ROLL_TYPES.MAINSHEC, "ChatRollMS") end

	function Master:BtnOS() AnnounceRoll(ROLL_TYPES.OFFSPEC, "ChatRollOS") end

	function Master:BtnSR() AnnounceRoll(ROLL_TYPES.RESERVED, "ChatRollSR") end

	function Master:BtnFree() AnnounceRoll(ROLL_TYPES.FREE, "ChatRollFree") end

	--
	-- Button: Starts or stops the roll countdown.
	--
	function Master:BtnCountdown()
		if isCountdownRunning then
			addon:RecordRolls(false)
			isCountdownRunning = false
		else
			addon:RecordRolls(true)
			announced = false
			isCountdownRunning = true
			countdownStart = GetTime()
			countdownPos = addon.options.countdownDuration + 1
		end
	end

	--
	-- Button: Clear Rolls
	--
	function Master:BtnClear()
		announced = false
		addon:ClearRolls()
	end

	--
	-- Button: Award/Trade
	--
	function Master:BtnAward()
		if lootCount <= 0 or rollsCount <= 0 then
			addon:Debug("DEBUG", "Cannot award, lootCount=%d, rollsCount=%d", lootCount or 0, rollsCount or 0)
			return
		end
		isCountdownRunning = false
		local itemLink = GetItemLink()
		_G[frameName .. "ItemCount"]:ClearFocus()
		if isFromInventory then
			TradeItem(itemLink, winner, currentRollType, addon:HighestRoll())
		else
			AssignItem(itemLink, winner, currentRollType, addon:HighestRoll())
		end
	end

	--
	-- Button: Hold item
	--
	function Master:BtnHold()
		if lootCount <= 0 or not holder then return end
		isCountdownRunning = false
		local itemLink = GetItemLink()
		if not itemLink then return end
		currentRollType = ROLL_TYPES.HOLD
		if isFromInventory then
			TradeItem(itemLink, holder, currentRollType, 0)
		else
			AssignItem(itemLink, holder, currentRollType, 0)
		end
	end

	--
	-- Button: Bank item
	--
	function Master:BtnBank()
		if lootCount <= 0 or not banker then return end
		isCountdownRunning = false
		local itemLink = GetItemLink()
		if not itemLink then return end
		currentRollType = ROLL_TYPES.BANK
		if isFromInventory then
			TradeItem(itemLink, banker, currentRollType, 0)
		else
			AssignItem(itemLink, banker, currentRollType, 0)
		end
	end

	--
	-- Button: Disenchant item
	--
	function Master:BtnDisenchant()
		if lootCount <= 0 or not disenchanter then return end
		isCountdownRunning = false
		local itemLink = GetItemLink()
		if not itemLink then return end
		currentRollType = ROLL_TYPES.DISENCHANT
		if isFromInventory then
			TradeItem(itemLink, disenchanter, currentRollType, 0)
		else
			AssignItem(itemLink, disenchanter, currentRollType, 0)
		end
	end

	--
	-- Selects a winner from the roll list.
	--
	function Master:SelectWinner(btn)
		if not btn then return end
		local btnName = btn:GetName()
		local playerName = _G[btnName .. "Name"]:GetText()
		if playerName then
			if IsControlKeyDown() then
				local rollValue = _G[btnName .. "Roll"]:GetText()
				addon:Announce(format(L.ChatPlayerRolled, playerName, rollValue))
				return
			end
			winner = playerName:trim()
			addon:FetchRolls()
			Utils.sync("KRT-RollWinner", playerName)
		end
		if itemCount == 1 then
			announced = false
		end
	end

	--
	-- Selects an item from the item selection frame.
	--
	function Master:BtnSelectedItem(btn)
		if not btn then return end
		local index = btn:GetID()
		if index then
			announced = false
			if selectionFrame then selectionFrame:Hide() end
			addon:SelectItem(index)
		end
	end

	--
	-- Localizes UI frame elements.
	--
	function LocalizeUIFrame()
		if isLocalized then return end
		if GetLocale() ~= "enUS" and GetLocale() ~= "enGB" then
			_G[frameName .. "ConfigBtn"]:SetText(L.BtnConfigure)
			_G[frameName .. "SelectItemBtn"]:SetText(L.BtnSelectItem)
			_G[frameName .. "SpamLootBtn"]:SetText(L.BtnSpamLoot)
			_G[frameName .. "MSBtn"]:SetText(L.BtnMS)
			_G[frameName .. "OSBtn"]:SetText(L.BtnOS)
			_G[frameName .. "SRBtn"]:SetText(L.BtnSR)
			_G[frameName .. "FreeBtn"]:SetText(L.BtnFree)
			_G[frameName .. "CountdownBtn"]:SetText(L.BtnCountdown)
			_G[frameName .. "AwardBtn"]:SetText(L.BtnAward)
			_G[frameName .. "RollBtn"]:SetText(L.BtnRoll)
			_G[frameName .. "ClearBtn"]:SetText(L.BtnClear)
			_G[frameName .. "HoldBtn"]:SetText(L.BtnHold)
			_G[frameName .. "BankBtn"]:SetText(L.BtnBank)
			_G[frameName .. "DisenchantBtn"]:SetText(L.BtnDisenchant)
			_G[frameName .. "Name"]:SetText(L.StrNoItemSelected)
			_G[frameName .. "RollsHeaderRoll"]:SetText(L.StrRoll)
			_G[frameName .. "OpenReservesBtn"]:SetText(L.BtnOpenReserves)
			_G[frameName .. "ImportReservesBtn"]:SetText(L.BtnImportReserves)
		end
		_G[frameName .. "Title"]:SetText(format(TITLE_STRING, MASTER_LOOTER))
		_G[frameName .. "ItemCount"]:SetScript("OnTextChanged", function() announced = false end)

		if not next(dropDownData) then
			for i = 1, 8 do dropDownData[i] = {} end
		end
		dropDownFrameHolder = _G[frameName .. "HoldDropDown"]
		dropDownFrameBanker = _G[frameName .. "BankDropDown"]
		dropDownFrameDisenchanter = _G[frameName .. "DisenchantDropDown"]
		PrepareDropDowns()
		UIDropDownMenu_Initialize(dropDownFrameHolder, InitializeDropDowns)
		UIDropDownMenu_Initialize(dropDownFrameBanker, InitializeDropDowns)
		UIDropDownMenu_Initialize(dropDownFrameDisenchanter, InitializeDropDowns)
		isLocalized = true
	end

	--
	-- OnUpdate handler for the frame, updates UI elements periodically.
	--
	function UpdateUIFrame(self, elapsed)
		if not isLocalized then LocalizeUIFrame() end

		if Utils.periodic(self, frameName, updateInterval, elapsed) then
			-- Item Count Handling
			local itemCountInput = _G[frameName .. "ItemCount"]
			itemCount = itemCountInput:GetNumber()
			if itemInfo.count and itemInfo.count ~= itemCount then
				if itemInfo.count < itemCount then
					itemCount = itemInfo.count
					itemCountInput:SetNumber(itemInfo.count)
				end
			end

			-- Dropdown Updates
			UpdateDropDowns(dropDownFrameHolder)
			UpdateDropDowns(dropDownFrameBanker)
			UpdateDropDowns(dropDownFrameDisenchanter)

			-- Button State Updates
			Utils.setText(_G[frameName .. "CountdownBtn"], L.BtnStop, L.BtnCountdown, isCountdownRunning)
			Utils.setText(_G[frameName .. "AwardBtn"], TRADE, L.BtnAward, isFromInventory)
			Utils.setText(_G[frameName .. "SelectItemBtn"], L.BtnRemoveItem, L.BtnSelectItem, isFromInventory)
			Utils.setText(_G[frameName .. "SpamLootBtn"], READY_CHECK, L.BtnSpamLoot, isFromInventory)

			-- Countdown Logic
			if isCountdownRunning then
				local tick = math.ceil(addon.options.countdownDuration - GetTime() + countdownStart)
				local i = countdownPos - 1
				while i >= tick do
					if i >= addon.options.countdownDuration then
						addon:Announce(L.ChatCountdownTic:format(i))
					elseif i >= 10 and i % 10 == 0 then
						addon:Announce(L.ChatCountdownTic:format(i))
					elseif (i > 0 and i < 10 and i % 7 == 0) or (i > 0 and i >= 5 and i % 5 == 0) or (i > 0 and i <= 3) then
						addon:Announce(L.ChatCountdownTic:format(i))
					end
					i = i - 1
				end
				countdownPos = tick
				if countdownPos <= 0 then
					isCountdownRunning = false
					addon:Announce(L.ChatCountdownEnd)
					if addon.options.countdownRollsBlock then
						addon:RecordRolls(false)
					end
				end
			end

			-- Enable/Disable Buttons
			local hasLoot = lootCount >= 1
			Utils.enableDisable(_G[frameName .. "SelectItemBtn"], lootCount > 1 or (isFromInventory and hasLoot))
			Utils.enableDisable(_G[frameName .. "SpamLootBtn"], hasLoot)
			Utils.enableDisable(_G[frameName .. "MSBtn"], hasLoot)
			Utils.enableDisable(_G[frameName .. "OSBtn"], hasLoot)
			Utils.enableDisable(_G[frameName .. "SRBtn"], hasLoot and addon.Reserves:HasData())
			Utils.enableDisable(_G[frameName .. "FreeBtn"], hasLoot)
			Utils.enableDisable(_G[frameName .. "CountdownBtn"], hasLoot and ItemExists())
			Utils.enableDisable(_G[frameName .. "HoldBtn"], hasLoot)
			Utils.enableDisable(_G[frameName .. "BankBtn"], hasLoot)
			Utils.enableDisable(_G[frameName .. "DisenchantBtn"], hasLoot)
			Utils.enableDisable(_G[frameName .. "AwardBtn"], hasLoot and rollsCount >= 1)
			Utils.enableDisable(_G[frameName .. "OpenReservesBtn"], addon.Reserves:HasData())
			Utils.enableDisable(_G[frameName .. "ImportReservesBtn"], not addon.Reserves:HasData())

			local _, record, canRoll, rolled = addon:RollStatus()
			Utils.enableDisable(_G[frameName .. "RollBtn"], record and canRoll and not rolled)
			Utils.enableDisable(_G[frameName .. "ClearBtn"], rollsCount >= 1)
		end
	end

	--
	-- Initializes the dropdown menus for player selection.
	--
	function InitializeDropDowns()
		if UIDROPDOWNMENU_MENU_LEVEL == 2 then
			local group = UIDROPDOWNMENU_MENU_VALUE
			local members = dropDownData[group]
			for name, _ in pairs(members) do
				local info = UIDropDownMenu_CreateInfo()
				info.notCheckable = 1
				info.text = name
				info.func = Master.OnClickDropDown
				info.arg1 = UIDROPDOWNMENU_OPEN_MENU
				info.arg2 = name
				UIDropDownMenu_AddButton(info, UIDROPDOWNMENU_MENU_LEVEL)
			end
		elseif UIDROPDOWNMENU_MENU_LEVEL == 1 then
			for group, hasMembers in pairs(dropDownGroupData) do
				if hasMembers then
					local info = UIDropDownMenu_CreateInfo()
					info.hasArrow = 1
					info.notCheckable = 1
					info.text = GROUP .. " " .. group
					info.value = group
					info.owner = UIDROPDOWNMENU_OPEN_MENU
					UIDropDownMenu_AddButton(info, UIDROPDOWNMENU_MENU_LEVEL)
				end
			end
		end
	end

	--
	-- Prepares the data for the dropdowns by fetching the raid roster.
	--
	function PrepareDropDowns()
		for i = 1, 8 do twipe(dropDownData[i]) end
		twipe(dropDownGroupData)
		for i = 1, GetRealNumRaidMembers() do
			local name, _, subgroup = GetRaidRosterInfo(i)
			if name then
				dropDownData[subgroup][name] = true
				dropDownGroupData[subgroup] = true
			end
		end
	end

	--
	-- OnClick handler for dropdown menu items.
	--
	function Master:OnClickDropDown(owner, value)
		if not KRT_CurrentRaid then return end
		UIDropDownMenu_SetText(owner, value)
		UIDropDownMenu_SetSelectedValue(owner, value)
		local name = owner:GetName()
		if name == dropDownFrameHolder:GetName() then
			KRT_Raids[KRT_CurrentRaid].holder = value
		elseif name == dropDownFrameBanker:GetName() then
			KRT_Raids[KRT_CurrentRaid].banker = value
		elseif name == dropDownFrameDisenchanter:GetName() then
			KRT_Raids[KRT_CurrentRaid].disenchanter = value
		end
		CloseDropDownMenus()
	end

	--
	-- Updates the text of the dropdowns to reflect the current selection.
	--
	function UpdateDropDowns(frame)
		if not frame or not KRT_CurrentRaid then return end
		local name = frame:GetName()
		if name == dropDownFrameHolder:GetName() then
			holder = KRT_Raids[KRT_CurrentRaid].holder
			if holder and addon:GetUnitID(holder) == "none" then
				holder = nil
				KRT_Raids[KRT_CurrentRaid].holder = nil
			end
			if holder then
				UIDropDownMenu_SetText(dropDownFrameHolder, holder)
				UIDropDownMenu_SetSelectedValue(dropDownFrameHolder, holder)
			end
		elseif name == dropDownFrameBanker:GetName() then
			banker = KRT_Raids[KRT_CurrentRaid].banker
			if banker and addon:GetUnitID(banker) == "none" then
				banker = nil
				KRT_Raids[KRT_CurrentRaid].banker = nil
			end
			if banker then
				UIDropDownMenu_SetText(dropDownFrameBanker, banker)
				UIDropDownMenu_SetSelectedValue(dropDownFrameBanker, banker)
			end
		elseif name == dropDownFrameDisenchanter:GetName() then
			disenchanter = KRT_Raids[KRT_CurrentRaid].disenchanter
			if disenchanter and addon:GetUnitID(disenchanter) == "none" then
				disenchanter = nil
				KRT_Raids[KRT_CurrentRaid].disenchanter = nil
			end
			if disenchanter then
				UIDropDownMenu_SetText(dropDownFrameDisenchanter, disenchanter)
				UIDropDownMenu_SetSelectedValue(dropDownFrameDisenchanter, disenchanter)
			end
		end
	end

	--
	-- Creates the item selection frame if it doesn't exist.
	--
	local function CreateSelectionFrame()
		if not selectionFrame then
			selectionFrame = CreateFrame("Frame", nil, UIMaster, "KRTSimpleFrameTemplate")
			selectionFrame:Hide()
		end
		local index = 1
		while _G[frameName .. "ItemSelectionBtn" .. index] do
			_G[frameName .. "ItemSelectionBtn" .. index]:Hide()
			index = index + 1
		end
	end

	--
	-- Updates the item selection frame with the current loot items.
	--
	function UpdateSelectionFrame()
		CreateSelectionFrame()
		local height = 5
		for i = 1, lootCount do
			local btnName = frameName .. "ItemSelectionBtn" .. i
			local btn = _G[btnName] or CreateFrame("Button", btnName, selectionFrame, "KRTItemSelectionButton")
			btn:SetID(i)
			btn:Show()

			_G[btnName .. "Name"]:SetText(GetItemName(i))
			_G[btnName .. "Icon"]:SetTexture(GetItemTexture(i))
			btn:SetPoint("TOPLEFT", selectionFrame, "TOPLEFT", 0, -height)
			height = height + 37
		end
		selectionFrame:SetHeight(height)
		if lootCount <= 0 then
			selectionFrame:Hide()
		end
	end

	--
	-- Assigns an item from the loot window to a player.
	--
	function AssignItem(itemLink, playerName, rollType, rollValue)
		local itemIndex
		for i = 1, GetNumLootItems() do
			if GetLootSlotLink(i) == itemLink then
				itemIndex = i
				break
			end
		end
		if not itemIndex then
			addon:PrintError(L.ErrCannotFindItem:format(itemLink))
			return false
		end

		for p = 1, 40 do
			if GetMasterLootCandidate(p) == playerName then
				GiveMasterLoot(itemIndex, p)
				local output, whisper
				if rollType <= ROLL_TYPES.FREE and addon.options.announceOnWin then
					output = L.ChatAward:format(playerName, itemLink)
				elseif rollType == ROLL_TYPES.HOLD and addon.options.announceOnHold then
					output = L.ChatHold:format(playerName, itemLink)
					if addon.options.lootWhispers then
						whisper = L.WhisperHoldAssign:format(itemLink)
					end
				elseif rollType == ROLL_TYPES.BANK and addon.options.announceOnBank then
					output = L.ChatBank:format(playerName, itemLink)
					if addon.options.lootWhispers then
						whisper = L.WhisperBankAssign:format(itemLink)
					end
				elseif rollType == ROLL_TYPES.DISENCHANT and addon.options.announceOnDisenchant then
					output = L.ChatDisenchant:format(itemLink, playerName)
					if addon.options.lootWhispers then
						whisper = L.WhisperDisenchantAssign:format(itemLink)
					end
				end

				if output and not announced then
					addon:Announce(output)
					announced = true
				end
				if whisper then Utils.whisper(playerName, whisper) end

				addon:Log(currentRollItem, playerName, rollType, rollValue)
				return true
			end
		end
		addon:PrintError(L.ErrCannotFindPlayer:format(playerName))
		return false
	end

	--
	-- Trades an item from inventory to a player.
	--
	function TradeItem(itemLink, playerName, rollType, rollValue)
		if itemLink ~= GetItemLink() then return end
		trader = unitName

		local output, whisper
		local keepItem = true
		if rollType <= ROLL_TYPES.FREE and addon.options.announceOnWin then
			output = L.ChatAward:format(playerName, itemLink)
			keepItem = false
		elseif rollType == ROLL_TYPES.HOLD and addon.options.announceOnHold then
			output = L.ChatNoneRolledHold:format(itemLink, playerName)
		elseif rollType == ROLL_TYPES.BANK and addon.options.announceOnBank then
			output = L.ChatNoneRolledBank:format(itemLink, playerName)
		elseif rollType == ROLL_TYPES.DISENCHANT and addon.options.announceOnDisenchant then
			output = L.ChatNoneRolledDisenchant:format(itemLink, playerName)
		end

		if keepItem then
			if rollType == ROLL_TYPES.HOLD then
				whisper = L.WhisperHoldTrade:format(itemLink)
			elseif rollType == ROLL_TYPES.BANK then
				whisper = L.WhisperBankTrade:format(itemLink)
			elseif rollType == ROLL_TYPES.DISENCHANT then
				whisper = L.WhisperDisenchantTrade:format(itemLink)
			end
		elseif itemCount > 1 then
			-- Announce multiple winners
			addon:ClearRaidIcons()
			SetRaidTarget(trader, 1)
			local rolls = addon:GetRolls()
			local winners = {}
			for i = 1, itemCount do
				if rolls[i] then
					if rolls[i].name == trader then
						tinsert(winners, "{star} " .. rolls[i].name .. "(" .. rolls[i].roll .. ")")
					else
						SetRaidTarget(rolls[i].name, i + 1)
						tinsert(winners, RAID_TARGET_MARKERS[i] .. " " .. rolls[i].name .. "(" .. rolls[i].roll .. ")")
					end
				end
			end
			output = L.ChatTradeMutiple:format(tconcat(winners, ", "), trader)
		elseif trader == winner then
			-- Trader won, clear state
			addon:ClearLoot()
			addon:ClearRolls(false)
			addon:ClearRaidIcons()
		elseif CheckInteractDistance(playerName, 2) == 1 then
			-- Player is in range for trade
			if itemInfo.isStack and not addon.options.ignoreStacks then
				addon:PrintWarning(L.ErrItemStack:format(itemLink))
				return false
			end
			ClearCursor()
			PickupContainerItem(itemInfo.bagID, itemInfo.slotID)
			if CursorHasItem() then
				InitiateTrade(playerName)
				if addon.options.screenReminder and not screenshotWarned then
					addon:PrintWarning(L.ErrScreenReminder)
					screenshotWarned = true
				end
			end
		elseif addon:GetUnitID(playerName) ~= "none" then
			-- Player is out of range
			addon:ClearRaidIcons()
			SetRaidTarget(trader, 1)
			SetRaidTarget(winner, 4)
			output = L.ChatTrade:format(playerName, itemLink)
		end

		if not announced then
			if output then addon:Announce(output) end
			if whisper then
				if playerName == trader then
					addon:ClearLoot()
					addon:ClearRolls()
					addon:RecordRolls(false)
				else
					Utils.whisper(playerName, whisper)
				end
			end
			if rollType <= ROLL_TYPES.FREE and playerName == trader then
				addon:Log(currentRollItem, trader, rollType, rollValue)
			end
			announced = true
		end
		return true
	end

	--------------------------------------------------------------------------
	-- Event Handlers & Callbacks
	--------------------------------------------------------------------------

	--
	-- ITEM_LOCKED: Triggered when an item is picked up from inventory.
	--
	function addon:ITEM_LOCKED(_, inBag, inSlot)
		if not inBag or not inSlot then return end
		local _, itemCount, _, _, _, _, itemLink = GetContainerItemInfo(inBag, inSlot)
		if not itemLink then return end

		_G[frameName .. "ItemBtn"]:SetScript("OnClick", function()
			if not ItemIsSoulbound(inBag, inSlot) then
				_G[frameName .. "ItemCount"]:SetText("")
				_G[frameName .. "ItemCount"]:ClearFocus()
				_G[frameName .. "ItemCount"]:Hide()

				isFromInventory = true
				addon:AddItem(itemLink)
				addon:PrepareItem()
				announced = false
				itemInfo = {
					bagID   = inBag,
					slotID  = inSlot,
					count   = GetItemCount(itemLink),
					isStack = (itemCount > 1),
				}
				if itemInfo.count > 1 then
					itemCount = itemInfo.count
					local itemCountInput = _G[frameName .. "ItemCount"]
					itemCountInput:SetText(itemInfo.count)
					itemCountInput:Show()
					itemCountInput:SetFocus()
				end
			end
			ClearCursor()
		end)
	end

	--
	-- LOOT_OPENED: Triggered when the loot window opens.
	--
	function addon:LOOT_OPENED()
		if self:IsMasterLooter() then
			isLootOpen = true
			announced = false
			self:FetchLoot()
			UpdateSelectionFrame()
			if lootCount >= 1 then UIMaster:Show() end
		end
	end

	--
	-- LOOT_CLOSED: Triggered when the loot window closes.
	--
	function addon:LOOT_CLOSED()
		if self:IsMasterLooter() then
			isLootOpen = false
			UIMaster:Hide()
			self:ClearLoot()
			self:ClearRolls()
			self:RecordRolls(false)
		end
	end

	--
	-- LOOT_SLOT_CLEARED: Triggered when an item is looted.
	--
	function addon:LOOT_SLOT_CLEARED()
		if self:IsMasterLooter() then
			self:FetchLoot()
			UpdateSelectionFrame()
			if lootCount >= 1 then
				UIMaster:Show()
			else
				UIMaster:Hide()
			end
		end
	end

	--
	-- TRADE_ACCEPT_UPDATE: Triggered during a trade.
	--
	function addon:TRADE_ACCEPT_UPDATE(targetAccepted, playerAccepted)
		if itemCount == 1 and trader and winner and trader ~= winner then
			if targetAccepted == 1 and playerAccepted == 1 then
				self:Log(currentRollItem, winner, currentRollType, self:HighestRoll())
				trader, winner = nil, nil
				self:ClearLoot()
				self:ClearRolls()
				self:RecordRolls(false)
				screenshotWarned = false
			end
		end
	end

	-- Callback for item changes
	addon:RegisterCallback("SetItem", function(_, newItemLink)
		local oldItemLink = GetItemLink()
		if oldItemLink ~= newItemLink then
			announced = false
		end
	end)
end

---============================================================================
-- Reserves Module
-- Manages item reserves, import, and display.
---============================================================================
do
	addon.Reserves = {}
	local Reserves = addon.Reserves

	-- UI Elements
	local frameName
	local reserveListFrame, scrollFrame, scrollChild
	local reserveItemRows, rowsByItemID = {}, {}

	-- State variables
	local isLocalized = false
	local updateInterval = 0.5
	local reservesData = {}
	local reservesByItemID = {}
	local pendingItemInfo = {}
	local collapsedBossGroups = {}

	-- Local functions
	local LocalizeUIFrame, UpdateUIFrame

	--------------------------------------------------------------------------
	-- Saved Data Management
	--------------------------------------------------------------------------

	function Reserves:Save()
		addon:Debug("DEBUG", "Saving reserves data. Entries: %d", Utils.tableLen(reservesData))
		KRT_SavedReserves = table.deepCopy(reservesData)
		KRT_SavedReserves.reservesByItemID = table.deepCopy(reservesByItemID)
	end

	function Reserves:Load()
		addon:Debug("DEBUG", "Loading reserves. Data exists: %s", tostring(KRT_SavedReserves ~= nil))
		if KRT_SavedReserves and next(KRT_SavedReserves) then
			reservesData = table.deepCopy(KRT_SavedReserves)
			reservesByItemID = table.deepCopy(KRT_SavedReserves.reservesByItemID or {})
		else
			twipe(reservesData)
			twipe(reservesByItemID)
		end
	end

	function Reserves:ResetSaved()
		addon:Debug("DEBUG", "Resetting saved reserves data.")
		KRT_SavedReserves = nil
		twipe(reservesData)
		twipe(reservesByItemID)
		self:RefreshWindow()
		self:CloseWindow()
		addon:Print(L.StrReserveListCleared)
	end

	function Reserves:HasData()
		return next(reservesData) ~= nil
	end

	--------------------------------------------------------------------------
	-- UI Window Management
	--------------------------------------------------------------------------

	function Reserves:ShowWindow()
		if not reserveListFrame then
			addon:PrintError("Reserve List frame not available.")
			return
		end
		addon:Debug("DEBUG", "Showing reserve list window.")
		reserveListFrame:Show()
		self:RefreshWindow()
	end

	function Reserves:CloseWindow()
		addon:Debug("DEBUG", "Closing reserve list window.")
		if reserveListFrame then reserveListFrame:Hide() end
	end

	function Reserves:ShowImportBox()
		addon:Debug("DEBUG", "Opening import reserves box.")
		local frame = _G["KRTImportWindow"]
		if not frame then
			addon:PrintError("KRTImportWindow not found.")
			return
		end
		frame:Show()
		if _G["KRTImportEditBox"] then
			_G["KRTImportEditBox"]:SetText("")
			_G["KRTImportEditBox"]:SetFocus()
		end
		_G[frame:GetName() .. "Title"]:SetText(format(TITLE_STRING, L.StrImportReservesTitle))
	end

	function Reserves:OnLoad(frame)
		addon:Debug("DEBUG", "Reserves frame loaded.")
		reserveListFrame = frame
		frameName = frame:GetName()

		frame:RegisterForDrag("LeftButton")
		frame:SetScript("OnDragStart", frame.StartMoving)
		frame:SetScript("OnDragStop", frame.StopMovingOrSizing)
		frame:SetScript("OnUpdate", UpdateUIFrame)
		frame:SetScript("OnShow", function() self:RefreshWindow() end)

		scrollFrame = frame.ScrollFrame or _G["KRTReserveListFrameScrollFrame"]
		scrollChild = scrollFrame and scrollFrame.ScrollChild or _G["KRTReserveListFrameScrollChild"]

		local buttons = {
			CloseButton = "CloseWindow",
			ClearButton = "ResetSaved",
			QueryButton = "QueryMissingItems",
		}
		for btnSuffix, method in pairs(buttons) do
			local btn = _G["KRTReserveListFrame" .. btnSuffix]
			if btn and self[method] then
				btn:SetScript("OnClick", function() self[method](self) end)
				addon:Debug("DEBUG", "Button '%s' assigned to method '%s'", btnSuffix, method)
			end
		end

		LocalizeUIFrame()

		local itemInfoFrame = CreateFrame("Frame")
		itemInfoFrame:RegisterEvent("GET_ITEM_INFO_RECEIVED")
		itemInfoFrame:SetScript("OnEvent", function(_, _, itemId)
			addon:Debug("DEBUG", "GET_ITEM_INFO_RECEIVED for itemId %d", itemId)
			if pendingItemInfo[itemId] then
				local name, link, _, _, _, _, _, _, _, tex = GetItemInfo(itemId)
				if name then
					addon:Debug("DEBUG", "Updating reserve data for item: %s", link)
					self:UpdateReserveItemData(itemId, name, link, tex)
					pendingItemInfo[itemId] = nil
				else
					addon:Debug("DEBUG", "Item info still missing for itemId %d", itemId)
				end
			end
		end)
	end

	--------------------------------------------------------------------------
	-- Localization and UI Update
	--------------------------------------------------------------------------

	function LocalizeUIFrame()
		if isLocalized then return end
		if frameName then
			_G[frameName .. "Title"]:SetText(format(TITLE_STRING, L.StrRaidReserves))
			addon:Debug("DEBUG", "Reserves UI localized.")
		end
		isLocalized = true
	end

	function UpdateUIFrame(self, elapsed)
		if not isLocalized then LocalizeUIFrame() end
		if Utils.periodic(self, frameName, updateInterval, elapsed) then
			local hasData = Reserves:HasData()
			Utils.enableDisable(_G[frameName .. "ClearButton"], hasData)
			Utils.enableDisable(_G[frameName .. "QueryButton"], hasData)
		end
	end

	--------------------------------------------------------------------------
	-- Reserve Data Handling
	--------------------------------------------------------------------------

	function Reserves:GetReserve(playerName)
		local playerKey = playerName:lower():trim()
		return reservesData[playerKey]
	end

	function Reserves:GetAllReserves()
		addon:Debug("DEBUG", "Fetching all reserves. Total players with reserves: %d", Utils.tableLen(reservesData))
		return reservesData
	end

	function Reserves:ParseCSV(csv)
		addon:Debug("DEBUG", "Starting to parse CSV data.")
		twipe(reservesData)
		twipe(reservesByItemID)

		local function cleanCSVField(field)
			if not field then return nil end
			return field:gsub('^"(.-)"$', '%1'):trim()
		end

		local isFirstLine = true
		for line in csv:gmatch("[^\r\n]+") do
			if isFirstLine then
				isFirstLine = false
			else
				local _, itemIdStr, source, playerName, class, spec, note, plus = line:match(
					'^"?(.-)"?,(.-),(.-),(.-),(.-),(.-),(.-),(.-)')

				itemIdStr = cleanCSVField(itemIdStr)
				source = cleanCSVField(source)
				playerName = cleanCSVField(playerName)
				class = cleanCSVField(class)
				spec = cleanCSVField(spec)
				note = cleanCSVField(note)
				plus = cleanCSVField(plus)

				local itemId = tonumber(itemIdStr)
				local normalizedName = playerName and playerName:lower():trim()

				if normalizedName and itemId then
					addon:Debug("DEBUG", "Processing player: %s, Item ID: %d", playerName, itemId)
					reservesData[normalizedName] = reservesData[normalizedName] or {
						original = playerName,
						reserves = {}
					}

					local existingEntry = false
					for _, entry in ipairs(reservesData[normalizedName].reserves) do
						if entry.rawID == itemId then
							entry.quantity = (entry.quantity or 1) + 1
							existingEntry = true
							addon:Debug("DEBUG", "Updated quantity for player %s, item ID %d. New quantity: %d",
								playerName, itemId, entry.quantity)
							break
						end
					end

					if not existingEntry then
						local entry = {
							rawID    = itemId,
							quantity = 1,
							class    = class and class ~= "" and class or nil,
							note     = note and note ~= "" and note or nil,
							plus     = tonumber(plus) or 0,
							source   = source and source ~= "" and source or nil
						}
						tinsert(reservesData[normalizedName].reserves, entry)
						reservesByItemID[itemId] = reservesByItemID[itemId] or {}
						tinsert(reservesByItemID[itemId], entry)
						addon:Debug("DEBUG", "Added new reserve entry for player %s, item ID %d", playerName, itemId)
					end
				end
			end
		end

		addon:Debug("DEBUG", "Finished parsing CSV data. Total reserves processed: %d", Utils.tableLen(reservesData))
		self:RefreshWindow()
		self:Save()
	end

	--------------------------------------------------------------------------
	-- Item Info Querying
	--------------------------------------------------------------------------

	function Reserves:QueryItemInfo(itemId)
		if not itemId then return end
		addon:Debug("DEBUG", "Querying info for itemId: %d", itemId)
		local name, link, _, _, _, _, _, _, _, tex = GetItemInfo(itemId)
		if name and link and tex then
			self:UpdateReserveItemData(itemId, name, link, tex)
			addon:Debug("DEBUG", "Successfully queried info for itemId: %d, Item Name: %s", itemId, name)
			return true
		else
			GameTooltip:SetOwner(UIParent, "ANCHOR_NONE")
			GameTooltip:SetHyperlink("item:" .. itemId)
			GameTooltip:Hide()
			pendingItemInfo[itemId] = true
			addon:Debug("DEBUG", "Info for itemId %d not cached, request sent.", itemId)
			return false
		end
	end

	function Reserves:QueryMissingItems()
		local count = 0
		addon:Debug("DEBUG", "Querying missing items in reserves.")
		for _, player in pairs(reservesData) do
			if type(player) == "table" and type(player.reserves) == "table" then
				for _, r in ipairs(player.reserves) do
					if not r.itemLink or not r.itemIcon then
						if not self:QueryItemInfo(r.rawID) then
							count = count + 1
						end
					end
				end
			end
		end
		addon:Print(count > 0 and format("Requested info for %d missing items.", count) or
			"All item information is available.")
		addon:Debug("DEBUG", "Total missing items requested: %d", count)
	end

	function Reserves:UpdateReserveItemData(itemId, itemName, itemLink, itemIcon)
		addon:Debug("DEBUG", "Updating reserve item data for itemId: %d", itemId)
		for _, player in pairs(reservesData) do
			if type(player) == "table" and player.reserves then
				for _, r in ipairs(player.reserves) do
					if r.rawID == itemId then
						r.itemName = itemName
						r.itemLink = itemLink
						r.itemIcon = itemIcon or "Interface\\Icons\\INV_Misc_QuestionMark"
					end
				end
			end
		end

		if not rowsByItemID[itemId] then return end
		for _, row in ipairs(rowsByItemID[itemId]) do
			row.icon:SetTexture(itemIcon or "Interface\\Icons\\INV_Misc_QuestionMark")
			row.nameText:SetText(itemLink or itemName or ("[Item " .. itemId .. "]"))
			row.iconBtn:SetScript("OnEnter", function(self)
				GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
				if itemLink then
					GameTooltip:SetHyperlink(itemLink)
				else
					GameTooltip:SetText("Item ID: " .. itemId, 1, 1, 1)
				end
				GameTooltip:Show()
			end)
			row.iconBtn:SetScript("OnLeave", GameTooltip.Hide)
		end
	end

	function Reserves:GetReserveCountForItem(itemId, playerName)
		local normalizedName = playerName and playerName:lower()
		local data = reservesData[normalizedName]
		if not data then return 0 end

		for _, r in ipairs(data.reserves or {}) do
			if r.rawID == itemId then
				return r.quantity or 1
			end
		end
		return 0
	end

	--------------------------------------------------------------------------
	-- UI Display
	--------------------------------------------------------------------------

	function Reserves:RefreshWindow()
		addon:Debug("DEBUG", "Refreshing reserve window.")
		if not reserveListFrame or not scrollChild then return end

		for _, row in ipairs(reserveItemRows) do row:Hide() end
		twipe(reserveItemRows)
		twipe(rowsByItemID)

		-- Group reserves by item source, ID, and quantity
		local grouped = {}
		for _, player in pairs(reservesData) do
			for _, r in ipairs(player.reserves or {}) do
				local key = (r.source or "Unknown") .. "||" .. r.rawID .. "||" .. (r.quantity or 1)
				grouped[key] = grouped[key] or {
					itemId   = r.rawID,
					quantity = r.quantity or 1,
					itemLink = r.itemLink,
					itemName = r.itemName,
					itemIcon = r.itemIcon,
					source   = r.source or "Unknown",
					players  = {}
				}
				tinsert(grouped[key].players, player.original)
			end
		end

		local displayList = {}
		for _, data in pairs(grouped) do tinsert(displayList, data) end
		table.sort(displayList, function(a, b)
			if a.source ~= b.source then return a.source < b.source end
			if a.itemId ~= b.itemId then return a.itemId < b.itemId end
			return a.quantity < b.quantity
		end)

		local rowHeight, yOffset = 34, 0
		local seenSources = {}

		for _, entry in ipairs(displayList) do
			local source = entry.source

			if not seenSources[source] then
				seenSources[source] = true
				if collapsedBossGroups[source] == nil then collapsedBossGroups[source] = false end

				local headerBtn = CreateFrame("Button", nil, scrollChild)
				headerBtn:SetSize(320, 28)
				headerBtn:SetPoint("TOPLEFT", 0, -yOffset)

				local label = headerBtn:CreateFontString(nil, "OVERLAY", "GameFontNormal")
				label:SetFont("Fonts\\FRIZQT__.TTF", 14, "OUTLINE")
				label:SetTextColor(1, 0.82, 0)
				local prefix = collapsedBossGroups[source] and "|TInterface\\Buttons\\UI-PlusButton-Up:12|t " or
					"|TInterface\\Buttons\\UI-MinusButton-Up:12|t "
				label:SetText(prefix .. source)
				label:SetPoint("CENTER")

				headerBtn:SetScript("OnClick", function()
					collapsedBossGroups[source] = not collapsedBossGroups[source]
					addon:Debug("DEBUG", "Toggling collapse state for source: %s to %s", source,
						tostring(collapsedBossGroups[source]))
					Reserves:RefreshWindow()
				end)

				tinsert(reserveItemRows, headerBtn)
				yOffset = yOffset + 24
			end

			if not collapsedBossGroups[source] then
				local row = self:CreateReserveRow(scrollChild, entry, yOffset, #reserveItemRows + 1)
				tinsert(reserveItemRows, row)
				yOffset = yOffset + rowHeight
			end
		end

		scrollChild:SetHeight(yOffset)
		scrollFrame:SetVerticalScroll(0)
	end

	function Reserves:CreateReserveRow(parent, info, yOffset, index)
		addon:Debug("DEBUG", "Creating reserve row for itemId: %d", info.itemId)
		local row = CreateFrame("Frame", nil, parent)
		row:SetSize(320, 34)
		row:SetPoint("TOPLEFT", 0, -yOffset)
		row._rawID = info.itemId

		local bg = row:CreateTexture(nil, "BACKGROUND")
		bg:SetAllPoints()
		bg:SetTexture("Interface\\Buttons\\WHITE8x8")
		bg:SetVertexColor(index % 2 == 0 and 0.1 or 0, 0.1, 0.1, 0.3)

		local icon = row:CreateTexture(nil, "ARTWORK")
		icon:SetSize(32, 32)
		icon:SetPoint("LEFT", 0, 0)

		row.iconBtn = CreateFrame("Button", nil, row)
		row.iconBtn:SetAllPoints(icon)

		row.nameText = row:CreateFontString(nil, "OVERLAY", "GameFontNormal")
		row.nameText:SetPoint("TOPLEFT", icon, "TOPRIGHT", 8, -2)
		row.nameText:SetText(info.itemLink or info.itemName or ("[Item " .. info.itemId .. "]"))

		local playerText = row:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
		playerText:SetPoint("TOPLEFT", row.nameText, "BOTTOMLEFT", 0, -2)
		playerText:SetText(tconcat(info.players or {}, ", "))

		local quantityText = row:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
		quantityText:SetPoint("BOTTOMRIGHT", icon, "BOTTOMRIGHT", -2, 2)
		quantityText:SetFont("Fonts\\FRIZQT__.TTF", 10, "OUTLINE")
		quantityText:SetTextColor(1, 1, 1)

		if info.quantity and info.quantity > 1 then
			quantityText:SetText(info.quantity .. "x")
			quantityText:Show()
		else
			quantityText:Hide()
		end

		icon:SetTexture(info.itemIcon or "Interface\\Icons\\INV_Misc_QuestionMark")

		row.iconBtn:SetScript("OnEnter", function(self)
			GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
			if info.itemLink then
				GameTooltip:SetHyperlink(info.itemLink)
			else
				GameTooltip:SetText("Item ID: " .. info.itemId, 1, 1, 1)
			end
			if info.source then
				GameTooltip:AddLine("Dropped by: " .. info.source, 0.8, 0.8, 0.8)
			end
			GameTooltip:Show()
		end)
		row.iconBtn:SetScript("OnLeave", GameTooltip.Hide)

		row.icon = icon
		row:Show()

		rowsByItemID[info.itemId] = rowsByItemID[info.itemId] or {}
		tinsert(rowsByItemID[info.itemId], row)

		return row
	end

	--------------------------------------------------------------------------
	-- SR Announcement Formatting
	--------------------------------------------------------------------------

	function Reserves:GetPlayersForItem(itemId)
		addon:Debug("DEBUG", "Getting players for itemId: %d", itemId)
		local players = {}
		for _, player in pairs(reservesData or {}) do
			for _, r in ipairs(player.reserves or {}) do
				if r.rawID == itemId then
					local qty = r.quantity or 1
					local display = qty > 1 and format("(%dx) %s", qty, player.original) or player.original
					tinsert(players, display)
					break
				end
			end
		end
		addon:Debug("DEBUG", "Returning %d players for itemId %d", #players, itemId)
		return players
	end

	function Reserves:FormatReservedPlayersLine(itemId)
		addon:Debug("DEBUG", "Formatting reserved players line for itemId: %d", itemId)
		local playerList = self:GetPlayersForItem(itemId)
		return #playerList > 0 and tconcat(playerList, ", ") or ""
	end
end

---============================================================================
-- Configuration Frame Module
---============================================================================
do
	addon.Config = {}
	local Config = addon.Config
	local frameName

	-- State variables
	local isLocalized = false
	local updateInterval = 0.1

	-- Local functions
	local LocalizeUIFrame, UpdateUIFrame

	--
	-- Default options for the addon.
	--
	local defaultOptions = {
		sortAscending          = false,
		useRaidWarning         = true,
		announceOnWin          = true,
		announceOnHold         = true,
		announceOnBank         = false,
		announceOnDisenchant   = false,
		lootWhispers           = false,
		screenReminder         = true,
		ignoreStacks           = false,
		showTooltips           = true,
		minimapButton          = true,
		countdownSimpleRaidMsg = false,
		countdownDuration      = 5,
		countdownRollsBlock    = true,
	}

	--
	-- Loads the default options into the settings table.
	--
	local function LoadDefaultOptions()
		for k, v in pairs(defaultOptions) do
			KRT_Options[k] = v
		end
		addon:PrintSuccess("Default options have been restored.")
	end

	--
	-- Loads addon options from saved variables, filling in defaults.
	--
	function LoadOptions()
		addon.options = KRT_Options
		Utils.fillTable(addon.options, defaultOptions)

		-- Ensure dependent options are consistent
		if not addon.options.useRaidWarning then
			addon.options.countdownSimpleRaidMsg = false
		end
	end

	--
	-- Public method to reset options to default.
	--
	function Config:Default()
		LoadDefaultOptions()
	end

	--
	-- OnLoad handler for the configuration frame.
	--
	function Config:OnLoad(frame)
		if not frame then return end
		UIConfig = frame
		frameName = frame:GetName()
		frame:RegisterForDrag("LeftButton")
		frame:SetScript("OnUpdate", UpdateUIFrame)
	end

	--
	-- Toggles the visibility of the configuration frame.
	--
	function Config:Toggle()
		Utils.toggle(UIConfig)
	end

	--
	-- Hides the configuration frame.
	--
	function Config:Hide()
		if UIConfig and UIConfig:IsShown() then
			UIConfig:Hide()
		end
	end

	--
	-- OnClick handler for option controls.
	--
	function Config:OnClick(btn)
		if not btn then return end
		frameName = frameName or btn:GetParent():GetName()
		local value, name = nil, btn:GetName()

		if name ~= frameName .. "countdownDuration" then
			value = btn:GetChecked() and true or false
			if name == frameName .. "minimapButton" then
				addon:ToggleMinimapButton()
			end
		else
			value = btn:GetValue()
			_G[frameName .. "countdownDurationText"]:SetText(value)
		end

		local optionKey = strsub(name, strlen(frameName) + 1)
		TriggerEvent("Config" .. optionKey, value)
		KRT_Options[optionKey] = value
	end

	--
	-- Localizes UI elements.
	--
	function LocalizeUIFrame()
		if isLocalized then return end
		if GetLocale() ~= "enUS" and GetLocale() ~= "enGB" then
			_G[frameName .. "sortAscendingStr"]:SetText(L.StrConfigSortAscending)
			_G[frameName .. "useRaidWarningStr"]:SetText(L.StrConfigUseRaidWarning)
			_G[frameName .. "announceOnWinStr"]:SetText(L.StrConfigAnnounceOnWin)
			_G[frameName .. "announceOnHoldStr"]:SetText(L.StrConfigAnnounceOnHold)
			_G[frameName .. "announceOnBankStr"]:SetText(L.StrConfigAnnounceOnBank)
			_G[frameName .. "announceOnDisenchantStr"]:SetText(L.StrConfigAnnounceOnDisenchant)
			_G[frameName .. "lootWhispersStr"]:SetText(L.StrConfigLootWhisper)
			_G[frameName .. "countdownRollsBlockStr"]:SetText(L.StrConfigCountdownRollsBlock)
			_G[frameName .. "screenReminderStr"]:SetText(L.StrConfigScreenReminder)
			_G[frameName .. "ignoreStacksStr"]:SetText(L.StrConfigIgnoreStacks)
			_G[frameName .. "showTooltipsStr"]:SetText(L.StrConfigShowTooltips)
			_G[frameName .. "minimapButtonStr"]:SetText(L.StrConfigMinimapButton)
			_G[frameName .. "countdownDurationStr"]:SetText(L.StrConfigCountdownDuration)
			_G[frameName .. "countdownSimpleRaidMsgStr"]:SetText(L.StrConfigCountdownSimpleRaidMsg)
		end
		_G[frameName .. "Title"]:SetText(format(TITLE_STRING, SETTINGS))
		_G[frameName .. "AboutStr"]:SetText(L.StrConfigAbout)
		_G[frameName .. "DefaultsBtn"]:SetScript("OnClick", LoadDefaultOptions)
		isLocalized = true
	end

	--
	-- OnUpdate handler for the configuration frame.
	--
	function UpdateUIFrame(self, elapsed)
		if not isLocalized then LocalizeUIFrame() end
		if Utils.periodic(self, frameName, updateInterval, elapsed) then
			-- Update checkbox states
			for option, value in pairs(addon.options) do
				local checkbox = _G[frameName .. option]
				if checkbox and checkbox.SetChecked then
					checkbox:SetChecked(value == true)
				end
			end

			-- Update slider
			_G[frameName .. "countdownDuration"]:SetValue(addon.options.countdownDuration)
			_G[frameName .. "countdownDurationText"]:SetText(addon.options.countdownDuration)

			-- Handle dependent options
			local useRaidWarningBtn = _G[frameName .. "useRaidWarning"]
			local simpleMsgBtn = _G[frameName .. "countdownSimpleRaidMsg"]
			local simpleMsgStr = _G[frameName .. "countdownSimpleRaidMsgStr"]

			if useRaidWarningBtn and simpleMsgBtn and simpleMsgStr then
				if not useRaidWarningBtn:GetChecked() then
					simpleMsgBtn:SetChecked(false) -- Force uncheck
					simpleMsgBtn:Disable()
					simpleMsgStr:SetTextColor(0.5, 0.5, 0.5)
				else
					simpleMsgBtn:Enable()
					simpleMsgStr:SetTextColor(HIGHLIGHT_FONT_COLOR.r, HIGHLIGHT_FONT_COLOR.g, HIGHLIGHT_FONT_COLOR.b)
					simpleMsgBtn:SetChecked(addon.options.countdownSimpleRaidMsg)
				end
			end
		end
	end
end

-- Slash Commands, Core Events, etc. continue in the file but are omitted here for brevity.
-- The subsequent modules like Warnings, MS Changes, LFM Spammer, Tooltips, and Logger
-- would follow a similar refactoring pattern.

---============================================================================
-- Slash Commands
---============================================================================
do
	local helpString = "|caaf49141%s|r: %s"

	--
	-- Main slash command handler.
	--
	local function HandleSlashCmd(input)
		if not input or input == "" then
			input = "help" -- Default to help
		end

		if input == "show" or input == "toggle" then
			addon.Master:Toggle()
			return
		end

		local cmd, arg1, arg2 = strsplit(" ", lower(input), 3)

		local commands = {
			-- Debugger
			debug = function()
				local actions = {
					clear  = function() addon.Debugger:Clear() end,
					show   = function() addon.Debugger:Show() end,
					hide   = function() addon.Debugger:Hide() end,
					toggle = function() if addon.Debugger:IsShown() then addon.Debugger:Hide() else addon.Debugger:Show() end end,
					level  = function()
						if not arg2 then
							addon.Debugger:Add("INFO", "Current log level: %s", addon.Debugger:GetMinLevel())
						else
							addon.Debugger:SetMinLevel(tonumber(arg2) or arg2)
						end
					end,
				}
				if actions[arg1] then actions[arg1]() else actions.toggle() end
			end,
			dbg = "debug",
			debugger = "debug",
			-- Config
			config = function()
				if arg1 == "reset" then
					addon.Config:Default()
				else
					addon.Config:Toggle()
				end
			end,
			conf = "config",
			options = "config",
			opt = "config",
			-- Warnings
			warnings = function()
				if not arg1 or arg1 == "toggle" then
					addon.Warnings:Toggle()
				elseif tonumber(arg1) then
					addon.Warnings:Announce(tonumber(arg1))
				else
					addon:Print(format(L.StrCmdCommands, "krt warnings"), "KRT")
					print(helpString:format("toggle", L.StrCmdToggle))
					print(helpString:format("<id>", L.StrCmdWarningAnnounce))
				end
			end,
			warn = "warnings",
			rw = "warnings",
			-- MS Changes
			ms = function()
				local actions = {
					demand   = function() addon.Changes:Demand() end,
					ask      = "demand",
					announce = function() addon.Changes:Announce() end,
					spam     = "announce",
					toggle   = function() addon.Changes:Toggle() end
				}
				if actions[arg1] then
					if type(actions[arg1]) == "string" then actions[actions[arg1]]() else actions[arg1]() end
				else
					actions.toggle()
				end
			end,
			changes = "ms",
			mschanges = "ms",
			-- Loot Log
			log = function() addon.Logger:Toggle() end,
			logger = "log",
			history = "log",
			-- Master Looter
			loot = function() addon.Master:Toggle() end,
			ml = "loot",
			master = "loot",
			-- Reserves
			reserves = function()
				if arg1 == "import" then
					addon.Reserves:ShowImportBox()
				else
					addon.Reserves:ShowWindow()
				end
			end,
			res = "reserves",
			reserve = "reserves",
			-- LFM Spammer
			lfm = function()
				local actions = {
					start  = function() addon.Spammer:Start() end,
					stop   = function() addon.Spammer:Stop() end,
					toggle = function() addon.Spammer:Toggle() end
				}
				if actions[arg1] then actions[arg1]() else actions.toggle() end
			end,
			pug = "lfm",
			group = "lfm",
			-- Help
			help = function()
				addon:Print(format(L.StrCmdCommands, "krt"), "KRT")
				print(helpString:format("config", L.StrCmdConfig))
				print(helpString:format("lfm", L.StrCmdGrouper))
				print(helpString:format("ms", L.StrCmdChanges))
				print(helpString:format("warnings", L.StrCmdWarnings))
				print(helpString:format("log", L.StrCmdLog))
				print(helpString:format("reserves", L.StrCmdReserves))
				print(helpString:format("debug", "Toggles the debug window."))
			end
		}

		if commands[cmd] then
			local action = commands[cmd]
			if type(action) == "string" then
				commands[action]()
			else
				action()
			end
		else
			commands.help()
		end
	end

	SLASH_KRT1, SLASH_KRT2 = "/krt", "/kraidtools"
	SlashCmdList["KRT"] = HandleSlashCmd

	SLASH_KRTCOUNTS1 = "/krtcounts"
	SlashCmdList["KRTCOUNTS"] = function()
		addon:ToggleCountsFrame() -- Loot Counter is not yet refactored.
	end
end

---============================================================================
-- Main Event Handlers
---============================================================================

--
-- ADDON_LOADED: Initializes the addon after loading.
--
function addon:ADDON_LOADED(name)
	if name ~= addonName then return end
	mainFrame:UnregisterEvent("ADDON_LOADED")

	self.Reserves:Load()

	self:RegisterEvents(
		"CHAT_MSG_SYSTEM",
		"CHAT_MSG_LOOT",
		"CHAT_MSG_MONSTER_YELL",
		"RAID_ROSTER_UPDATE",
		"PLAYER_ENTERING_WORLD",
		"COMBAT_LOG_EVENT_UNFILTERED",
		"RAID_INSTANCE_WELCOME",
		-- Master Looter Events
		"ITEM_LOCKED",
		"LOOT_CLOSED",
		"LOOT_OPENED",
		"LOOT_SLOT_CLEARED",
		"TRADE_ACCEPT_UPDATE"
	)
	self:RAID_ROSTER_UPDATE()
end

--
-- RAID_ROSTER_UPDATE: Updates the raid roster when it changes.
--
function addon:RAID_ROSTER_UPDATE()
	self:UpdateRaidRoster()
end

--
-- RAID_INSTANCE_WELCOME: Triggered when entering a raid instance.
--
function addon:RAID_INSTANCE_WELCOME(_, nextReset)
	local instanceName, _, instanceDiff = GetInstanceInfo()
	KRT_NextReset = nextReset
	if L.RaidZones[instanceName] then
		Utils.schedule(3, function()
			addon.Raid:Check(instanceName, instanceDiff)
		end)
	end
end

--
-- PLAYER_ENTERING_WORLD: Performs initial checks when the player logs in.
--
function addon:PLAYER_ENTERING_WORLD()
	mainFrame:UnregisterEvent("PLAYER_ENTERING_WORLD")
	Utils.schedule(3, self.Raid.FirstCheck)
end

--
-- CHAT_MSG_LOOT: Adds looted items to the raid log.
--
function addon:CHAT_MSG_LOOT(msg)
	if KRT_CurrentRaid then
		self.Raid:AddLoot(msg)
	end
end

--
-- CHAT_MSG_MONSTER_YELL: Logs a boss kill based on specific boss yells.
--
function addon:CHAT_MSG_MONSTER_YELL(text, bossName)
	if L.BossYells[text] and KRT_CurrentRaid then
		self.Raid:AddBoss(L.BossYells[text])
	end
end

--
-- COMBAT_LOG_EVENT_UNFILTERED: Logs a boss kill when a boss unit dies.
--
function addon:COMBAT_LOG_EVENT_UNFILTERED(_, event, _, _, _, destGUID, destName)
	if not KRT_CurrentRaid then return end
	if event == "UNIT_DIED" then
		local npcID = Utils.GetNPCID(destGUID)
		if BossIDs.BossIDs[npcID] then
			self.Raid:AddBoss(destName)
		end
	end
end
